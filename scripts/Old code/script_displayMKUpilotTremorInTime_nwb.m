% script for comparing tremor power and timecourse between Mela, Kiwi, and
% Uva. 
clear; clc

%%
% Loading and saving pathways
clear nwb
nwbDataPath = 'D:\PROJECTS\Thalamic DBS for Harmaline Tremors\Data Acquisition\NWBdata\';
projRootPath = 'L:\My Drive\PROJECTS\Thalamic DBS for Harmaline Tremors\';

% % Uva dose study data of choice:
% nwbFullPath = nwbDataPath;
% % SESSION_ID = 'TremoLfpDBS-190927-100155'; % 2 mg/kg day
% % SESSION_ID = 'TremoLfpDBS-191004-100637'; % 4 mg/kg day
% % SESSION_ID = 'TremoLfpDBS-191011-104322'; % 6 mg/kg day
% % SESSION_ID = 'TremoLfpDBS-191018-100615'; % 8 mg/kg day
% % SESSION_ID = 'TremoLfpDBS-191025-104651'; % 2 mg/kg day
% % SESSION_ID = 'TremoLfpDBS-191101-101430'; % 4 mg/kg day
% % SESSION_ID = 'TremoLfpDBS-191108-101829'; % 6 mg/kg day
% SESSION_ID = 'TremoLfpDBS-191115-100127'; % 8 mg/kg day

% Remove Chronux from Matlab's searchpath to prevent a problem with
% jacknife function used by bootci
rmpath(genpath('C:\Users\bello043\Documents\GitHub\Thalamic-DBS-HarmalineTremor\toolboxes\chronux_2_10'))



%%

% CONFIGURATION & CONSTANTS
% decide whether to show all figures generated by workflow
cfg.displayWorkflowFigs = false;

% (the the rest of the constants See inside "tremorWorkflow" function at bottom of script)

cfg.fcDetrend = 1; % Hz

% Spectrogram parameters:
cfg.TWIN = 1; % seconds, sliding time-window of spectrogram
cfg.NOVERLAP = 0; % samples, no overlaps for these spectrogam windows

% Movement artifact removal
cfg.MADthresh = 3; % median limit for outliers

% Tremor frequency band
% trPeak = 10; % Hz, major tremor component
% trRange = 3; % limits of tremor band around major component
% cfg.tremorBand = [6, 12]; % Hz

% General movement frequency band
generalBand = [17, 21];

% Tremor power summary statistic & bootstrapped estimation of confidence interval
% myStatFun = @(x)mean(x);
cfg.NBOOTS = 1000;

% If any time-series recordings MUCH larger than the typical small size,
% break into smaller segments for display
cfg.tooBigTime = 240; % seconds
cfg.subSegTime = 90; % seconds
cfg.tooSmallTime = 30; % seconds

cfg.tooSparseData = 30;

% Baseline estimate statistic

% Test for segments vs baseline
statTest = @(x)signrank(x);

% False Discovery Rate for Benjamini-Hochberg procedure for multiple
% comparisons
fdr = 0.001;



%% Mela's data

% Mela Pilot data of choice: 12 mg/kg day
nwbFullPath = [nwbDataPath 'MelaPilot\'];
% SESSION_ID = 'harPilotMela-150928-094900'; % 2 mg/kg day
% SESSION_ID = 'harPilotMela-150930-082000'; % 6 mg/kg day
SESSION_ID = 'harPilotMela-151013-072100'; % 12 mg/kg day

% Load nwb master file for this session, get acc TimeSeries object
disp('Reading NWB file...')
nwbM = nwbRead([nwbFullPath SESSION_ID '_MASTER.nwb']);
disp('DONE!')

% Calculate spectrogram-based tremor power for segments of recorded data
cfg.tremorBand = [8, 12]; % Hz
[tremPowM, tstSegHarRefM, resultsM] = func_gatherACCproc_fbandTimeSegs_har(nwbM, cfg);

% Calculate spectrogram-based non-tremor power for segments of recorded data
cfg.tremorBand = generalBand; % Hz
[notremPowM, ~] = func_gatherACCproc_fbandTimeSegs_har(nwbM, cfg);

[powCompM] = comparePow(tremPowM, notremPowM);

% define baseline data
baseSegs = powCompM(1);
base = [];
for i = 1:length(baseSegs)
    base = [base, baseSegs{i}];
    
end
baseAvM = median(base);

% Get % change from expected baseline for all data:
nSegs = length(tremPowM);
for iSeg = 1:nSegs
%     percDeltaM{iSeg,1} = 100 * (powCompM{iSeg} - baseAvM) / baseAvM;
    percDeltaM{iSeg,1} = 100 * powCompM{iSeg} / baseAvM;

    
end


% Prepare that data into format that can be plotted by errorbar function
% [tmidM,powM,cinegM,ciposM,tnegM,tposM] = func_prepACCproc_fbandTimeSegs_errorbar(...
%     tremPowM, tstSegHarRefM, cfg);
% [tmidM,powM,cinegM,ciposM,tnegM,tposM] = func_prepACCproc_fbandTimeSegs_errorbar(...
%     powCompM, tstSegHarRefM, cfg);
[tmidM,powM,cinegM,ciposM,tnegM,tposM] = func_prepACCproc_fbandTimeSegs_errorbar(...
    percDeltaM, tstSegHarRefM, cfg);


nSegs = length(tremPowM);
for iSeg = 1:nSegs
    numPointsM(iSeg) = numel(tremPowM{iSeg});
    
end


% Benjamini Hochberg procedure
nSegs = length(powCompM);
for iSeg = 1:nSegs
%     [hM(iSeg), pvalsM(iSeg)] = ttest(powCompM{iSeg} - baseAvM);
    [pvalsM(iSeg), hM(iSeg)] = signrank(percDeltaM{iSeg} - 100);

    
end
[hCorrM, crit_pM, adjCicvrg, adj_p] = fdr_bh(pvalsM, fdr, 'pdep');
tmidMsig = tmidM(hCorrM);
powMsig = powM(hCorrM);
tmidMnosig = tmidM(~hCorrM);
powMnosig = powM(~hCorrM);



%% Kiwi's data (hi band)

% Kiwi Pilot data of choice: 10 mg/kg day
nwbFullPath = [nwbDataPath 'KiwiPilot\'];
SESSION_ID = 'harPilotKiwi-160517-122121';

% Load nwb master file for this session, get acc TimeSeries object
disp('Reading NWB file...')
nwbK = nwbRead([nwbFullPath SESSION_ID '_MASTER.nwb']);
disp('DONE!')

cfg.tremorBand = [12, 16]; % Hz
% Calculate spectrogram-based tremor power for segments of recorded data
[tremPowKhi, tstSegHarRefKhi, resultsKhi] = func_gatherACCproc_fbandTimeSegs_har(nwbK, cfg);

% Calculate spectrogram-based non-tremor power for segments of recorded data
cfg.tremorBand = generalBand; % Hz
[notremPowKhi, ~] = func_gatherACCproc_fbandTimeSegs_har(nwbK, cfg);

[powCompKhi] = comparePow(tremPowKhi, notremPowKhi);


% define baseline data
baseSegshi = powCompKhi(1:2);
basehi = [];
for i = 1:length(baseSegshi)
    basehi = [basehi, baseSegshi{i}];
    
end
baseAvKhi = median(basehi);

% Get % change from expected baseline for all data:
nSegs = length(tremPowKhi);
for iSeg = 1:nSegs
%     percDeltaKhi{iSeg,1} = 100 * (powCompKhi{iSeg} - baseAvKhi) / baseAvKhi;
    percDeltaKhi{iSeg,1} = 100 * powCompKhi{iSeg} / baseAvKhi;

    
end


% Prepare that data into format that can be plotted by errorbar function
% [tmidK,powK,cinegK,ciposK,tnegK,tposK] = func_prepACCproc_fbandTimeSegs_errorbar(...
%     tremPowK, tstSegHarRefK, cfg);
% [tmidK,powK,cinegK,ciposK,tnegK,tposK] = func_prepACCproc_fbandTimeSegs_errorbar(...
%     powCompK, tstSegHarRefK, cfg);
[tmidKhi,powKhi,cinegKhi,ciposKhi,tnegKhi,tposKhi] = func_prepACCproc_fbandTimeSegs_errorbar(...
    percDeltaKhi, tstSegHarRefKhi, cfg);


nSegs = length(tremPowKhi);
for iSeg = 1:nSegs
    numPointsKhi(iSeg) = numel(tremPowKhi{iSeg});
    
end


% Benjamini Hochberg procedure
nSegs = length(powCompKhi);
for iSeg = 1:nSegs
%     [hK(iSeg), pvalsK(iSeg)] = ttest(powCompK{iSeg} - baseAvK);
    [pvalsKhi(iSeg), hKhi(iSeg)] = signrank(percDeltaKhi{iSeg} - 100);
    
end
[hCorrKhi, crit_pKhi, adjCicvrghi, adj_phi] = fdr_bh(pvalsKhi, fdr, 'pdep');
tmidKsighi = tmidKhi(hCorrKhi);
powKsighi = powKhi(hCorrKhi);
tmidKnosighi = tmidKhi(~hCorrKhi);
powKnosighi = powKhi(~hCorrKhi);



%% Kiwi's data (lo band)

% Kiwi Pilot data of choice: 10 mg/kg day
nwbFullPath = [nwbDataPath 'KiwiPilot\'];
SESSION_ID = 'harPilotKiwi-160517-122121';

% Load nwb master file for this session, get acc TimeSeries object
disp('Reading NWB file...')
nwbK = nwbRead([nwbFullPath SESSION_ID '_MASTER.nwb']);
disp('DONE!')

cfg.tremorBand = [4, 8]; % Hz
% Calculate spectrogram-based tremor power for segments of recorded data
[tremPowKlo, tstSegHarRefKlo, resultsKlo] = func_gatherACCproc_fbandTimeSegs_har(nwbK, cfg);

% Calculate spectrogram-based non-tremor power for segments of recorded data
cfg.tremorBand = generalBand; % Hz
[notremPowKlo, ~] = func_gatherACCproc_fbandTimeSegs_har(nwbK, cfg);

[powCompKlo] = comparePow(tremPowKlo, notremPowKlo);


% define baseline data
baseSegslo = powCompKlo(1:2);
baselo = [];
for i = 1:length(baseSegslo)
    baselo = [baselo, baseSegslo{i}];
    
end
baseAvKlo = median(baselo);

% Get % change from expected baseline for all data:
nSegs = length(tremPowKlo);
for iSeg = 1:nSegs
%     percDeltaKlo{iSeg,1} = 100 * (powCompKlo{iSeg} - baseAvKlo) / baseAvKlo;
    percDeltaKlo{iSeg,1} = 100 * powCompKlo{iSeg} / baseAvKlo;

    
end


% Prepare that data into format that can be plotted by errorbar function
% [tmidK,powK,cinegK,ciposK,tnegK,tposK] = func_prepACCproc_fbandTimeSegs_errorbar(...
%     tremPowK, tstSegHarRefK, cfg);
% [tmidK,powK,cinegK,ciposK,tnegK,tposK] = func_prepACCproc_fbandTimeSegs_errorbar(...
%     powCompK, tstSegHarRefK, cfg);
[tmidKlo,powKlo,cinegKlo,ciposKlo,tnegKlo,tposKlo] = func_prepACCproc_fbandTimeSegs_errorbar(...
    percDeltaKlo, tstSegHarRefKlo, cfg);


nSegs = length(tremPowKlo);
for iSeg = 1:nSegs
    numPointsKlo(iSeg) = numel(tremPowKlo{iSeg});
    
end


% Benjamini Hochberg procedure
nSegs = length(powCompKlo);
for iSeg = 1:nSegs
%     [hK(iSeg), pvalsK(iSeg)] = ttest(powCompK{iSeg} - baseAvK);
    [pvalsKlo(iSeg), hKlo(iSeg)] = signrank(percDeltaKlo{iSeg} - 100);
    
end
[hCorrKlo, crit_pKlo, adjCicvrglo, adj_plo] = fdr_bh(pvalsKlo, fdr, 'pdep');
tmidKsiglo = tmidKlo(hCorrKlo);
powKsiglo = powKlo(hCorrKlo);
tmidKnosiglo = tmidKlo(~hCorrKlo);
powKnosiglo = powKlo(~hCorrKlo);



%% Uva's data

% Uva Pilot data of choice: 8 mg/kg day
nwbFullPath = [nwbDataPath 'UvaPilot\'];
% SESSION_ID = 'harPilotUva-180219-132618'; % 8 mg/kg day
SESSION_ID = 'harPilotUva-180221-113120'; % 12 mg/kg day
% SESSION_ID = 'harPilotUva-180305-103016'; % 12 mg/kg day

% Load nwb master file for this session, get acc TimeSeries object
disp('Reading NWB file...')
nwbU = nwbRead([nwbFullPath SESSION_ID '_MASTER.nwb']);
disp('DONE!')

cfg.tremorBand = [8, 12]; % Hz
% Calculate spectrogram-based tremor power for segments of recorded data
[tremPowU, tstSegHarRefU, resultsU] = func_gatherACCproc_fbandTimeSegs_har(nwbU, cfg);

% Calculate spectrogram-based non-tremor power for segments of recorded data
cfg.tremorBand = generalBand; % Hz
[notremPowU, ~] = func_gatherACCproc_fbandTimeSegs_har(nwbU, cfg);

[powCompU] = comparePow(tremPowU, notremPowU);

% define baseline data
baseSegs = powCompU(1:9);
base = [];
for i = 1:length(baseSegs)
    base = [base, baseSegs{i}];
    
end
baseAvU = median(base);

% Get % change from expected baseline for all data:
nSegs = length(tremPowU);
for iSeg = 1:nSegs
%     percDeltaU{iSeg,1} = 100 * (powCompU{iSeg} - baseAvU) / baseAvU;
    percDeltaU{iSeg,1} = 100 * powCompU{iSeg} / baseAvU;

    
end


% Prepare that data into format that can be plotted by errorbar function
% [tmidU,powU,cinegU,ciposU,tnegU,tposU] = func_prepACCproc_fbandTimeSegs_errorbar(...
%     tremPowU, tstSegHarRefU, cfg);
% [tmidU,powU,cinegU,ciposU,tnegU,tposU] = func_prepACCproc_fbandTimeSegs_errorbar(...
%     powCompU, tstSegHarRefU, cfg);
[tmidU,powU,cinegU,ciposU,tnegU,tposU] = func_prepACCproc_fbandTimeSegs_errorbar(...
    percDeltaU, tstSegHarRefU, cfg);


nSegs = length(tremPowU);
for iSeg = 1:nSegs
    numPointsU(iSeg) = numel(tremPowU{iSeg});
    
end


% Benjamini Hochberg procedure
nSegs = length(powCompU);
for iSeg = 1:nSegs
%     [hU(iSeg), pvalsU(iSeg)] = ttest(powCompU{iSeg} - baseAvU);
    [pvalsU(iSeg), hU(iSeg)] = signrank(percDeltaU{iSeg} - 100);

end
[hCorrU, crit_pU, adjCicvrg, adj_p] = fdr_bh(pvalsU, fdr, 'pdep');
tmidUsig = tmidU(hCorrU);
powUsig = powU(hCorrU);
tmidUnosig = tmidU(~hCorrU);
powUnosig = powU(~hCorrU);


%% Display All results
% RGB gray: [128 128 128]
% RGB dark-orange: [255 140 0]
errbCapSize = 0;
errbLineWidth = 1;
errbC = 'k';

scatSz = 40;
scatCnosig = 'k'; 
scatCsig = 'r';

harLineWidth = 1.5;

pchipLineStyle = '--';
linC_M = 'b';
linC_K = 'm';
linC_U = 'g';


% Look at tremor power over time for each subject
titStr = '%\Delta Tremor-Ratio';
genBandStr = '[17-21Hz]';
figure;
set(gcf, 'Position', [2083 66 1735 919]);

% Mela's
s = 1;
ax(s) = subplot(4,1,s);
errorbar(tmidM,powM,cinegM,ciposM,[],[], '.',  ...
    'CapSize', errbCapSize, 'LineWidth', errbLineWidth,'Color', errbC);
grid on; hold on;
% xq = tmidM(1):0.1:tmidM(end);
% cs = pchip(tmidM, powM);
% plot(xq, ppval(cs,xq));
xqM = tmidM(1):0.1:tmidM(end);
yyM = pchip(tmidM, powM, xqM);
pM = plot(xqM, yyM, 'LineStyle', pchipLineStyle, 'Color', linC_M);
scatter(tmidMsig, powMsig, scatSz, scatCsig, 'filled');
scatter(tmidMnosig, powMnosig, scatSz, scatCnosig, 'filled');
ax(s).YLim(1) = 0;
plot([0 0], [ax(s).YLim], 'r', 'LineWidth', harLineWidth)

% ylabel([titStr ' ([8-12Hz] / ' genBandStr ')'])
ylabel(titStr)
% legend(pM, 'S1, 12 mg/kg', 'Location', 'northeastoutside')

title('Accelerometer tremor/non-tremor Power-ratio following Harmaline injection')



% Kiwi's hi band
s = 2;
ax(s) = subplot(4,1,s);
errorbar(tmidKhi,powKhi,cinegKhi,ciposKhi,[],[], '.', ...
    'CapSize', errbCapSize, 'LineWidth', errbLineWidth, 'Color', errbC);
grid on; hold on;
xqKhi = tmidKhi(1):0.1:tmidKhi(end);
yyKhi = pchip(tmidKhi, powKhi, xqKhi);
pKhi = plot(xqKhi, yyKhi, 'LineStyle', pchipLineStyle, 'Color', linC_K);
scatter(tmidKsighi, powKsighi, scatSz, scatCsig, 'filled');
scatter(tmidKnosighi, powKnosighi, scatSz, scatCnosig, 'filled');
ax(s).YLim(1) = 0;
plot([0 0], [ax(s).YLim], 'r', 'LineWidth', harLineWidth)

% ylabel([titStr ' ([12-16Hz] / ' genBandStr ')'])
ylabel(titStr)
% legend(pKhi, 'S2 hi-band, 10 mg/kg', 'Location', 'northeastoutside')



% Kiwi's lo band
s = 3;
ax(s) = subplot(4,1,s);
errorbar(tmidKlo,powKlo,cinegKlo,ciposKlo,[],[], '.', ...
    'CapSize', errbCapSize, 'LineWidth', errbLineWidth, 'Color', errbC);
grid on; hold on;
xqKlo = tmidKlo(1):0.1:tmidKlo(end);
yyKlo = pchip(tmidKlo, powKlo, xqKlo);
pKlo = plot(xqKlo, yyKlo, 'LineStyle', pchipLineStyle, 'Color', linC_K);
scatter(tmidKsiglo, powKsiglo, scatSz, scatCsig, 'filled');
scatter(tmidKnosiglo, powKnosiglo, scatSz, scatCnosig, 'filled');
ax(s).YLim(1) = 0;
plot([0 0], [ax(s).YLim], 'r', 'LineWidth', harLineWidth)

% ylabel([titStr ' ([12-16Hz] / ' genBandStr ')'])
ylabel(titStr)
% legend(pKlo, 'S2 lo-band, 10 mg/kg', 'Location', 'northeastoutside')



% Uva's
s = 4;
ax(s) = subplot(4,1,s);
errorbar(tmidU,powU,cinegU,ciposU,[],[], '.', ...
    'CapSize', errbCapSize, 'LineWidth', errbLineWidth, 'Color', errbC);
grid on; hold on;
xqU = tmidU(1):0.1:tmidU(end);
yyU = pchip(tmidU, powU, xqU);
pU = plot(xqU, yyU, 'LineStyle', pchipLineStyle, 'Color', linC_U);
scatter(tmidUsig, powUsig, scatSz, scatCsig, 'filled');
scatter(tmidUnosig, powUnosig, scatSz, scatCnosig, 'filled');
ax(s).YLim(1) = 0;
plot([0 0], [ax(s).YLim], 'r', 'LineWidth', harLineWidth)

% ylabel([titStr ' ([8-12Hz] / ' genBandStr ')'])
ylabel(titStr)
% legend(pU, 'S3, 12 mg/kg', 'Location', 'northeastoutside')

xlabel('Time since harmaline inject (mins)');
set(ax(:), 'XLim', [-10 150]);
set(ax(:), 'XTick', [-10:10:150])
% set(ax(:), 'YLim', [0 22]);


%%
% Figure comparing all subjects on same scale
% Look at tremor power over time for each subject
titStr = '%\Delta Tremor-Ratio';
pchipLineStyle = '-';
pchipLineWidth = 3;


figure;
set(gcf, 'Position', [2083 66 1735 919]);

axAll = axes;
hold on

% Mela
pM = plot(xqM, yyM, 'Color', linC_M, ...
    'LineStyle', pchipLineStyle, ...
    'LineWidth', pchipLineWidth);
% scatter(tmidMsig, powMsig, scatSz, scatCsig, 'filled');
% scatter(tmidMnosig, powMnosig, scatSz, scatCnosig, 'filled');
% errorbar(tmidM,powM,cinegM,ciposM,[],[], '.', ...
%     'CapSize', errbCapSize, 'LineWidth', errbLineWidth, 'Color', errbC);

% Kiwi hi-band
pKhi = plot(xqKhi, yyKhi, 'Color', linC_K, ...
    'LineStyle', '-.', ...
    'LineWidth', pchipLineWidth);
% scatter(tmidKsig, powKsig, scatSz, scatCsig, 'filled');
% scatter(tmidKnosig, powKnosig, scatSz, scatCnosig, 'filled');
% errorbar(tmidK,powK,cinegK,ciposK,[],[], '.', ...
%     'CapSize', errbCapSize, 'LineWidth', errbLineWidth, 'Color', errbC);

% Kiwi
pKlo = plot(xqKlo, yyKlo, 'Color', linC_K, ...
    'LineStyle', '--', ...
    'LineWidth', pchipLineWidth);
% scatter(tmidKsig, powKsig, scatSz, scatCsig, 'filled');
% scatter(tmidKnosig, powKnosig, scatSz, scatCnosig, 'filled');
% errorbar(tmidK,powK,cinegK,ciposK,[],[], '.', ...
%     'CapSize', errbCapSize, 'LineWidth', errbLineWidth, 'Color', errbC);

% Uva
pU = plot(xqU, yyU, 'Color', linC_U, ...
    'LineStyle', pchipLineStyle, ...
    'LineWidth', pchipLineWidth);
% scatter(tmidUsig, powUsig, scatSz, scatCsig, 'filled');
% scatter(tmidUnosig, powUnosig, scatSz, scatCnosig, 'filled');
% errorbar(tmidU,powU,cinegU,ciposU,[],[], '.', ...
%     'CapSize', errbCapSize, 'LineWidth', errbLineWidth, 'Color', errbC);


grid minor
plot([0 0], [axAll.YLim], 'r', 'LineWidth', harLineWidth)

ylabel(titStr)
legend([pM pKhi pKlo pU], 'S1, 12 mg/kg', 'S2 hi-band, 10 mg/kg', ...
    'S2 lo-band, 10 mg/kg',  'S3, 12 mg/kg', ...
    'Location', 'northeastoutside');
axAll.XLim = [-10 150];
axAll.YLim(1) = 0;



%% look at number of points in data segments for each subject
% figure;
% set(gcf, 'Position', [2083 66 1735 919]);
% 
% % Mela's
% s = 1;
% ax(s) = subplot(3,1,s);
% errorbar(tmidM,numPointsM,[],[],tnegM,tposM, '.', ...
%     'CapSize', 0, 'LineWidth', 3);
% grid on; hold on;
% % ax(s).YLim = [0 22];
% plot([0 0], [ax(s).YLim], 'r')
% % ylabel('8-12Hz ACC Power (A.U.)')
% % legend('S1, 12 mg/kg', 'Location', 'northeastoutside')
% % 
% % title('tremor/non-tremor Power following Harmaline injection')
% 
% 
% % Kiwi's
% s = 2;
% ax(s) = subplot(3,1,s);
% errorbar(tmidK,numPointsK,[],[],tnegK,tposK, '.', ...
%     'CapSize', 0, 'LineWidth', 3);
% grid on; hold on;
% % ax(s).YLim = [0 22];
% plot([0 0], [ax(s).YLim], 'r')
% % ylabel('12-16Hz ACC Power (A.U.)')
% % legend('S2, 10 mg/kg', 'Location', 'northeastoutside')
% 
% 
% 
% % Uva's
% s = 3;
% ax(s) = subplot(3,1,s);
% errorbar(tmidU,numPointsU,[],[],tnegU,tposU, '.', ...
%     'CapSize', 0, 'LineWidth', 3);
% grid on; hold on;
% % ax(s).YLim = [0 5];
% plot([0 0], [ax(s).YLim], 'r')
% % ylabel('8-12Hz ACC Power (A.U.)')
% % legend('S3, 12 mg/kg', 'Location', 'northeastoutside')
% % 
% % xlabel('Time since harmaline inject (mins)');
% set(ax(:), 'XLim', [-10 150]);
% % set(ax(:), 'YLim', [0 22]);
% 


%% SUB-FUNCTIONS

function [powComp] = comparePow(tremPowM, notremPowM)

nSegs = length(tremPowM);
for iSeg = 1:nSegs
    powComp{iSeg,1} = tremPowM{iSeg} ./ notremPowM{iSeg};
    
end

end


function [accSegFinal, tstSegFinal] = segmentacc(acc, tst, ctrl, maxSamp)
% separate acc data and timestamps into time segments based on recordings.
% Large recordings are further subdivided into smaller time segements according
% to max segment time. maxTime (seconds). ctrl has zero at the start of
% every recording. 

% for acc and tst composed of N separate recordings, ctrl tracks which data
% belongs to which N recording

% detect the number of segments
nSegs = max(ctrl);
for iSeg = 1:nSegs
    accSeg{iSeg,1} = acc((ctrl == iSeg),1:3);
    tstSeg{iSeg,1} = tst((ctrl == iSeg));
    nSamps(iSeg) = sum(ctrl == iSeg);
    
end

% If any segments are too long according to maxSamp 
accSegFinal = {};
tstSegFinal = {};
if exist('maxSamp', 'var')
    for iSeg = 1:nSegs
        if nSamps(iSeg) > maxSamp % Too big! subdivide the segment into smaller ones
            nSubs = floor(nSamps(iSeg)/maxSamp) + 1;
            tempAcc = accSeg{iSeg,1};
            tempTst = tstSeg{iSeg,1};
            
            % mark subdivisions with indices
            xb = 1:(nSubs-1);
            bIdx = [1, xb*maxSamp + 1];
            eIdx = [xb*maxSamp, nSamps(iSeg)];
            
            % loop-fill the new subsections to be added
            for iSub = 1:nSubs
                accSegFinal = [accSegFinal; {tempAcc(bIdx(iSub):eIdx(iSub),1:3)}];
                tstSegFinal = [tstSegFinal; {tempTst(bIdx(iSub):eIdx(iSub))}];
                
            end
            
%             xb = [1:nRowsAdd]';
% 
%             % begIdxCorr
%             begIdxSmall = begIdx(i) + xb*maxSamp + 1;
%             begIdxCorr = [begIdxCorr; begIdx(i); begIdxSmall];
% 
%             % endIdxCorr
%             endIdxSmall = begIdx(i) + xb*maxSamp;
%             endIdxCorr = [endIdxCorr; endIdxSmall; endIdx(i)];

        else
            accSegFinal = [accSegFinal; accSeg(iSeg,1)];
            tstSegFinal = [tstSegFinal; tstSeg(iSeg,1)];
        
        end
    
        
        
    end
    
else % simple case where maxSamp is not entered into the function, no subdivision done
    accSegFinal = accSeg;
    tstSegFinal = tstSeg;
    
end




% 
% 
% begIdx = find(ctrl == 0);
% endIdx = [(begIdx(2:end)-1); length(ctrl)];
% % nSamps = diff([begIdx endIdx], [], 2);
% 
% % enforce maximum samples for each segment
% % isToobig = nSamps > maxSamp;
% nSamps = diff([begIdx endIdx], [], 2);
% begIdxCorr = [];
% endIdxCorr = [];
% for i = 1:length(begIdx)
% 
%     if diff([begIdx(i) endIdx(i)], [], 2) > maxSamp % Too big! break up the segment into smaller ones
%         nRowsAdd = floor(nSamps(i)/maxSamp); 
%         xb = [1:nRowsAdd]';
%         
%         % begIdxCorr
%         begIdxSmall = begIdx(i) + xb*maxSamp + 1;
%         begIdxCorr = [begIdxCorr; begIdx(i); begIdxSmall];
%         
%         % endIdxCorr
%         endIdxSmall = begIdx(i) + xb*maxSamp;
%         endIdxCorr = [endIdxCorr; endIdxSmall; endIdx(i)];
%         
%     else
%         begIdxCorr = [begIdxCorr; begIdx(i)];
%         endIdxCorr = [endIdxCorr; endIdx(i)];
%         
%     end
%     
%     
%     
% end


% Gather data segments
% nSegs = length(begIdxCorr);
% for iSeg = 1:nSegs
%     accSeg{iSeg,1} = acc(begIdxCorr(iSeg):endIdxCorr(iSeg),:);
%     tstSeg{iSeg,1} = tst(begIdxCorr(iSeg):endIdxCorr(iSeg),:);
%     
% end


end

function [accProc, tstProc] = fillACC(acc, tst, ctrl, fs)
% pre-process acc data so that missing values are interpolated and
% inter-file spaces are NaNs spaced out according to common
% sampling-frequency of all files in session
% ctrl goes from 0 to N for a single file of N samples (some may be
% missing). For an NWB file where multiple files were concatenated, the 0
% to N ctrl count will reset and start again from 0 at the startint point
% of the next file. 


Ts = 1/fs;                           % Sampling Time
% tst = [0:10  14:20  25:30]*0.00274;       % Create Time Series With Gaps
% acc = rand(size(tst));                      % Create Matching Data
tst = tst';
tn = round(tst/Ts);                       % Create Indices With Gaps
dt = diff([0 tn]);                      % Create Vector Of Differences
tg = find(dt > 1);                      % Find Indices Of Gaps
gaps = dt(tg)-1;                        % Find Lengths Of Gaps
ti = linspace(min(tst),max(tst),max(tn));   % Create Continuous Time Vector
fi = interp1(tst,acc,ti);                   % Create Matching Data Vector
for k1 = 1:length(tg)                   % Loop Filling Gaps In ‘f’ With NaN
    q = [tg(k1):tg(k1)+gaps(k1)-1];
    fi(tg(k1):tg(k1)+gaps(k1)-2) = nan(1,gaps(k1)-1);
end


% First subdivide 




nCtrls = length(ctrl);
for ictrl = 1:nCtrls
    
    
end

% then interpolate any short missing values within recordings


end

function [Sacc, f, tSpec] = spectrogramacc3(acc, fs, cfg)

% Detrend data, linear best fit is subtracted from each channel
acc = detrend(acc);


% Highpass filter out slow components

[b,a] = butter(3, cfg.fcDetrend/(fs/2), 'high');
accFilt = filtfilt(b, a, acc);



%% Get combined triaxial spectrogram

window = floor(cfg.TWIN * fs);

% Sum PSDs from all 3 accel channels
clear Z S
for ch = 1:3
    [Z(:,:,ch), f, tSpec] = spectrogram(accFilt(:,ch), window, cfg.NOVERLAP, [], fs, 'yaxis');
    % tRef = linspace(tSpec(1), tSpec(end), numel(tSpec));
    S(:,:,ch) = abs(Z(:,:,ch));
    S(:,:,ch) = S(:,:,ch).^2;

end
% Combine spectral power from all three axes (summate)
Sacc = sum(S, 3);

end

function ScleanCell = removeMovArtInAll(SaccCell, cfg)
% First concatenate all segments spectrograms together and keep track of
% their place within segment cells
nSegs = length(SaccCell);
SaccAll = [];
origIdx = [];
for iSeg = 1:nSegs
    iSacc = SaccCell{iSeg,1};
    origIdx = [origIdx, 1:size(iSacc, 2)]; % keeps tabls of time windows in spectrograms
    SaccAll = [SaccAll, SaccCell{iSeg,1}];   
    
end


% Identify movement artifact windows in spectrogram

[~, isMovArt] = util.remoutliers(sum(SaccAll, 1), ...
    'bound', 'upper', ...
    'MADthresh', cfg.MADthresh);
temp = SaccAll;
temp(:,isMovArt) = NaN;
SaccMarkOutliers = SaccAll;
SaccMarkOutliers(:,isMovArt) = NaN;


% Show Spectrogram with detected movement artifacts marked as 100's values
if cfg.displayWorkflowFigs
    f4 = figure;
    ax4 = axes;
    ax4.Parent = f4;
    surf(tSpec, f, 10*log10(SaccMarkOutliers), ...
        'Parent', ax4, ...
        'EdgeColor', 'none');
    hold(ax4, 'on');
    xlabel('Time (min)');
    grid on
    axis(ax4, 'tight')
    view(0,90)
    colorbar
    % ax4.YLim = [0, 300];
    % ax4.CLim = [-80, -30];
    title('Mov Artifacts marked');
    ylabel('Frequency (Hz)');
    f4.Position = [2555 57 560 421];

end

% Show Spectrogram with movement artifacts removed totally
if cfg.displayWorkflowFigs
    f4 = figure;
    ax4 = axes;
    ax4.Parent = f4;
%     tset = t;
%     tset(isMovArt) = [];
    surf(1:size(temp, 2), f, 10*log10(temp), ...
        'Parent', ax4, ...
        'EdgeColor', 'none');
    hold(ax4, 'on');
    xlabel('samples');
    grid on
    axis(ax4, 'tight')
    view(0,90)
    colorbar
    ax4.YLim = [0, 150];
    % ax4.CLim = [-80, -30];
    title('Mov Artifacts removed')
    ylabel('Frequency (Hz)');
    f4.Position = [2554 566 560 420];

end


% Get average PSD free of movement artifact windows
ScleanAll = temp; % movement artifact windows removed
% PSD = mean(ScleanAll, 2);
if cfg.displayWorkflowFigs
    f1 = figure; ax = axes;
    plot(f, (PSD));
    grid on; 
    ax.XLim = [0, 35];
    %     ax.YLim = [0, popMaxPSD];
    xlabel('Frequency (Hz)');
%     title(['Minutes since harmaline inject: ' num2str(minutes(sessTabRow.harRefTime(1)))], 'Interpreter', 'none')

end


% Output nan-marked spectrograms back in their original cells
begIdx = find(origIdx == 1);
endIdx = [(begIdx(2:end)-1), size(ScleanAll, 2)];
for iSeg = 1:nSegs
    ScleanCell{iSeg,1} = ScleanAll(:,(begIdx(iSeg):endIdx(iSeg)));
    
end

% Remove nan-marked columns in each spectrogram (pertaining to time-window
% labeled as movemend artifact) for each segment
for iSeg = 1:nSegs
    iSaccnan = ScleanCell{iSeg,1};
    nanIdx = isnan(sum(iSaccnan, 1));
    iSaccClean = iSaccnan;
    iSaccClean(:,nanIdx) = [];
    
    ScleanCell{iSeg,1} = iSaccClean;
    
end



end