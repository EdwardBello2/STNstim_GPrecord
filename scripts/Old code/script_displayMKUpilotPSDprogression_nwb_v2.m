% script for displaying ACC PSDs over the data-segments in time for each
% subject. Purpose: to visually see the PSD shape change. As for the
% time-element, that's covered in script_displayMKUpilotTremorInTime_nwb.m,
% focusing on the tremor-power/non-tremor power ratio over time. 

% VERSION 2: similar goal as version 1, but PSD is now calcualted from all
% long continuous time series (with movement artifact intervals excised)
% from each data segment, rather than from the average of all valid
% spectrogram windows as before. Will allow for finer frequency resolution
% of PSD. Also, the peak frequency tracking is now based strictly on the 
% PSD rather than the distribution of all spectrogam window "PSD"s.

clear; clc

%%
% Loading and saving pathways
clear nwb
nwbDataPath = 'D:\PROJECTS\Thalamic DBS for Harmaline Tremors\Data Acquisition\NWBdata\';
projRootPath = 'L:\My Drive\PROJECTS\Thalamic DBS for Harmaline Tremors\';

% % Uva dose study data of choice:
% nwbFullPath = nwbDataPath;
% % SESSION_ID = 'TremoLfpDBS-190927-100155'; % 2 mg/kg day
% % SESSION_ID = 'TremoLfpDBS-191004-100637'; % 4 mg/kg day
% % SESSION_ID = 'TremoLfpDBS-191011-104322'; % 6 mg/kg day
% % SESSION_ID = 'TremoLfpDBS-191018-100615'; % 8 mg/kg day
% % SESSION_ID = 'TremoLfpDBS-191025-104651'; % 2 mg/kg day
% % SESSION_ID = 'TremoLfpDBS-191101-101430'; % 4 mg/kg day
% % SESSION_ID = 'TremoLfpDBS-191108-101829'; % 6 mg/kg day
% SESSION_ID = 'TremoLfpDBS-191115-100127'; % 8 mg/kg day

% Remove Chronux from Matlab's searchpath to prevent a problem with
% jacknife function used by bootci
rmpath(genpath('C:\Users\bello043\Documents\GitHub\Thalamic-DBS-HarmalineTremor\toolboxes\chronux_2_10'))



%%

% CONFIGURATION & CONSTANTS
% decide whether to show all figures generated by workflow
cfg.displayWorkflowFigs = false;

% (the the rest of the constants See inside "tremorWorkflow" function at bottom of script)

cfg.fcDetrend = 1; % Hz

% Spectrogram parameters:
cfg.TWIN = 1; % seconds, sliding time-window of spectrogram
cfg.NOVERLAP = 0; % samples, no overlaps for these spectrogam windows

% Movement artifact removal
cfg.MADthresh = 3; % median limit for outliers

% Tremor frequency band
% trPeak = 10; % Hz, major tremor component
% trRange = 3; % limits of tremor band around major component
% cfg.tremorBand = [6, 12]; % Hz

% General movement frequency band
generalBand = [17, 21];

% Tremor power summary statistic & bootstrapped estimation of confidence interval
% myStatFun = @(x)mean(x);
cfg.NBOOTS = 1000;

% If any time-series recordings MUCH larger than the typical small size,
% break into smaller segments for display
cfg.tooBigTime = 240; % seconds
cfg.subSegTime = 90; % seconds
cfg.tooSmallTime = 30; % seconds

cfg.tooSparseData = 30;

% Baseline estimate statistic

% Test for segments vs baseline
statTest = @(x)signrank(x);

% False Discovery Rate for Benjamini-Hochberg procedure for multiple
% comparisons
fdr = 0.005;

errbCapSize = 0;
errbLineWidth = 1;
errbC = 'k';

scatSz = 30;
scatC = 'k'; 
scatCsig = 'r';

harLineWidth = 1.5;

pchipLineStyle = '--';
linC_M = 'b';
linC_K = 'm';
linC_U = 'g';


artOffset = 0.5; % seconds; this is the extra time window extension of all existing artifact time windows. ex: offset of 0.5 means taht [4, 5] becomes [3.5, 5.5]


% PWELCH INPUTS
% PSDwindow = 2^12;
windowTime = 4; % seconds
noverlap = []; % [] means default of 50% overlap
nfft = []; % [] means default input (see doc pwelch)


% LINEAR FITS TO FREQUENCY PEAKS: 1-degree polynomial fit
p1_M = -0.0241;
p2_M = 11.19;

p1_K = -0.0165;
p2_K = 15.38;

p1_U = -0.008875;
p2_U = 10.68;


%% Mela's data

% Mela Pilot data of choice: 12 mg/kg day
nwbFullPath = [nwbDataPath 'MelaPilot\'];
% SESSION_ID = 'harPilotMela-150928-094900'; % 2 mg/kg day
% SESSION_ID = 'harPilotMela-150930-082000'; % 6 mg/kg day
SESSION_ID = 'harPilotMela-151013-072100'; % 12 mg/kg day


% Load nwb master file for this session, get acc TimeSeries object
disp('Reading NWB file...')
nwbM = nwbRead([nwbFullPath SESSION_ID '_MASTER.nwb']);
disp('DONE!')


% Get timeseries data of processed trixial ACC data
[acc, tst, ctrl, fs] =  getACCprocData(nwbM);


% Gather timeseries data into data segments based on "ctrl", stored in
% separate cells
tooBigSamp = floor(fs * cfg.tooBigTime);
subSamp = floor(fs * cfg.subSegTime);
[accSeg, tstSeg] = nwbnrtl.util.segmentTseriesByCtrl(acc, tst, ctrl, ...
    tooBigSamp, subSamp);


% Excise movement artifact data and re-stitch good data back together
movArtObj = nwbM.acquisition.get('movementArtifacts').deref().intervalseries.get('movementArtifactIntervals');
dataArt = movArtObj.data.load;
tstArt = movArtObj.timestamps.load;
intervArt = [tstArt(dataArt > 0), tstArt(dataArt < 0)];
intervArt = [intervArt(:,1) - artOffset, intervArt(:,2) + artOffset]; % increase the range of artifact intervals by the offset


nSegs = length(accSeg);
for iSeg = 1:nSegs
    i_acc3 = accSeg{iSeg};
    i_tst = tstSeg{iSeg};
%     figure; plot(i_tst, i_acc3)
    i_acc3Clean = exciseArts_dataSegment(i_acc3, i_tst, intervArt);
    
    accSeg{iSeg} = i_acc3Clean;
    
end


% % Get PSD from one segment at a time
nSegs = length(accSeg);
for iSeg = 1:nSegs
    acc3 = accSeg{iSeg};
    window = floor(windowTime * fs);
    [pxxSeg{iSeg,1}, fM, pxxc] = getPSDdataSeg(acc3, window, noverlap, nfft, fs);
    psdSeg{iSeg,1} = sum(pxxSeg{iSeg,1}, 2);
    
%     figure('Position', [2029 458 560 420]);
%     plot(fM, sum(pxxSeg{iSeg}, 2));
%     hold on;
%     plot(fM, pxxc(:,1) + pxxc(:,3) + pxxc(:,5));
%     plot(fM, pxxc(:,2) + pxxc(:,4) + pxxc(:,6));
%     set(gca, 'XLim', [0 35]);

%     nDiv = length(acc3) / window
    
end
set(gca, 'XLim', [0 35]);
psdDispM = psdSeg;


% Get time midpoints of each data segmetn, corrected for time since
% harmaline injection
% Adjust timestamps to reflect harmaline injection time (t = 0)
tmidM = get_tmidSegHarRef(tstSeg, nwbM);
tmidM = tmidM / 60; % convert from seconds to minutes



% Get frequency peaks for each data segment
fspan = [0 35];
[psdFpksSegsM, psdPpksSegsM] = getSegmentPSDpeaks(psdDispM, fM, fspan);



% Display peak frequency over time
s = 1;
figure('Position', [1985 61 560 420]); 
axFpks(s) = axes;

plot_psdFpksSegs_vs_tmid(tmidM, psdFpksSegsM, [p1_M p2_M]);

ylabel('Frequency (Hz)')
title('Mela frequency peaks')



%% Kiwi's data

% Kiwi Pilot data of choice: 10 mg/kg day
nwbFullPath = [nwbDataPath 'KiwiPilot\'];
SESSION_ID = 'harPilotKiwi-160517-122121';

% Load nwb master file for this session, get acc TimeSeries object
disp('Reading NWB file...')
nwbK = nwbRead([nwbFullPath SESSION_ID '_MASTER.nwb']);
disp('DONE!')


% Get timeseries data of processed trixial ACC data
[acc, tst, ctrl, fs] =  getACCprocData(nwbK);


% Gather timeseries data into data segments based on "ctrl", stored in
% separate cells
tooBigSamp = floor(fs * cfg.tooBigTime);
subSamp = floor(fs * cfg.subSegTime);
[accSeg, tstSeg] = nwbnrtl.util.segmentTseriesByCtrl(acc, tst, ctrl, ...
    tooBigSamp, subSamp);


% Excise movement artifact data and re-stitch good data back together
movArtObj = nwbK.acquisition.get('movementArtifacts').deref().intervalseries.get('movementArtifactIntervals');
dataArt = movArtObj.data.load;
tstArt = movArtObj.timestamps.load;
intervArt = [tstArt(dataArt > 0), tstArt(dataArt < 0)];
intervArt = [intervArt(:,1) - artOffset, intervArt(:,2) + artOffset]; % increase the range of artifact intervals by the offset


nSegs = length(accSeg);
for iSeg = 1:nSegs
    i_acc3 = accSeg{iSeg};
    i_tst = tstSeg{iSeg};
%     figure; plot(i_tst, i_acc3)
    i_acc3Clean = exciseArts_dataSegment(i_acc3, i_tst, intervArt);
    
    accSeg{iSeg} = i_acc3Clean;
    
end


% % Get PSD from one segment at a time
nSegs = length(accSeg);
for iSeg = 1:nSegs
    acc3 = accSeg{iSeg};
    window = floor(windowTime * fs);
    [pxxSeg{iSeg,1}, fK, pxxc] = getPSDdataSeg(acc3, window, noverlap, nfft, fs);
    psdSeg{iSeg,1} = sum(pxxSeg{iSeg,1}, 2);
    
%     figure('Position', [2029 458 560 420]);
%     plot(fK, sum(pxxSeg{iSeg}, 2));
%     hold on;
%     plot(fK, pxxc(:,1) + pxxc(:,3) + pxxc(:,5));
%     plot(fK, pxxc(:,2) + pxxc(:,4) + pxxc(:,6));
%     set(gca, 'XLim', [0 35]);
    
%     nDiv = length(acc3) / window
    
end
set(gca, 'XLim', [0 35]);
psdDispK = psdSeg;


% Get time midpoints of each data segmetn, corrected for time since
% harmaline injection
% Adjust timestamps to reflect harmaline injection time (t = 0)
tmidK = get_tmidSegHarRef(tstSeg, nwbK);
tmidK = tmidK / 60; % convert from seconds to minutes



% Get frequency peaks for each data segment: high band
fspan = [0 10];
[psdFpksSegsKhi, psdPpksSegsKhi] = getSegmentPSDpeaks(psdDispK, fK, fspan);

% Get frequency peaks for each data segment: low band
fspan = [10 35];
[psdFpksSegsKlo, psdPpksSegsKlo] = getSegmentPSDpeaks(psdDispK, fK, fspan);



% Display peak frequency over time
s = 2;
figure('Position', [2549 62 560 420]); 
axFpks(s) = axes;

plot_psdFpksSegs_vs_tmid(tmidK, psdFpksSegsKhi, [p1_K p2_K]); hold on
plot_psdFpksSegs_vs_tmid(tmidK, psdFpksSegsKlo);


ylabel('Frequency (Hz)')
title('Kiwi frequency peaks')



%% Uva's data

% Uva Pilot data of choice: 8 mg/kg day
nwbFullPath = [nwbDataPath 'UvaPilot\'];
% SESSION_ID = 'harPilotUva-180219-132618'; % 8 mg/kg day
SESSION_ID = 'harPilotUva-180221-113120'; % 12 mg/kg day
% SESSION_ID = 'harPilotUva-180305-103016'; % 12 mg/kg day

% Load nwb master file for this session, get acc TimeSeries object
disp('Reading NWB file...')
nwbU = nwbRead([nwbFullPath SESSION_ID '_MASTER.nwb']);
disp('DONE!')


% Get timeseries data of processed trixial ACC data
[acc, tst, ctrl, fs] =  getACCprocData(nwbU);


% Gather timeseries data into data segments based on "ctrl", stored in
% separate cells
tooBigSamp = floor(fs * cfg.tooBigTime);
subSamp = floor(fs * cfg.subSegTime);
[accSeg, tstSeg] = nwbnrtl.util.segmentTseriesByCtrl(acc, tst, ctrl, ...
    tooBigSamp, subSamp);


% Excise movement artifact data and re-stitch good data back together
movArtObj = nwbU.acquisition.get('movementArtifacts').deref().intervalseries.get('movementArtifactIntervals');
dataArt = movArtObj.data.load;
tstArt = movArtObj.timestamps.load;
intervArt = [tstArt(dataArt > 0), tstArt(dataArt < 0)];
intervArt = [intervArt(:,1) - artOffset, intervArt(:,2) + artOffset]; % increase the range of artifact intervals by the offset


nSegs = length(accSeg);
for iSeg = 1:nSegs
    i_acc3 = accSeg{iSeg};
    i_tst = tstSeg{iSeg};
%     figure; plot(i_tst, i_acc3)
    i_acc3Clean = exciseArts_dataSegment(i_acc3, i_tst, intervArt);
    
    accSeg{iSeg} = i_acc3Clean;
    
end


% % Get PSD from one segment at a time
nSegs = length(accSeg);
for iSeg = 1:nSegs
    acc3 = accSeg{iSeg};
    window = floor(windowTime * fs);
    [pxxSeg{iSeg,1}, fU, pxxc] = getPSDdataSeg(acc3, window, noverlap, nfft, fs);
    psdSeg{iSeg,1} = sum(pxxSeg{iSeg,1}, 2);
    
%     figure('Position', [2029 458 560 420]);
%     plot(fU, sum(pxxSeg{iSeg}, 2));
%     hold on;
%     plot(fU, pxxc(:,1) + pxxc(:,3) + pxxc(:,5));
%     plot(fU, pxxc(:,2) + pxxc(:,4) + pxxc(:,6));
%     set(gca, 'XLim', [0 35]);
    
%     nDiv = length(acc3) / window
    
end
set(gca, 'XLim', [0 35]);
psdDispU = psdSeg;


% Get time midpoints of each data segmetn, corrected for time since
% harmaline injection
% Adjust timestamps to reflect harmaline injection time (t = 0)
tmidU = get_tmidSegHarRef(tstSeg, nwbU);
tmidU = tmidU / 60; % convert from seconds to minutes



% Get frequency peaks for each data segment
fspan = [0 35];
[psdFpksSegsU, psdPpksSegsU] = getSegmentPSDpeaks(psdDispU, fU, fspan);



% Display peak frequency over time
s = 3;
figure('Position', [3112 63 560 420]); 
axFpks(s) = axes;

plot_psdFpksSegs_vs_tmid(tmidU, psdFpksSegsU, [p1_U p2_U]);

ylabel('Frequency (Hz)')
title('Uva frequency peaks')



%% Display All results
% RGB gray: [128 128 128]
% RGB dark-orange: [255 140 0]

% view3d = [18.6000 36.2000];
view3d = [16.2000 73];
freqLim = [0 25];
linWid = 1.0;
sm = 1;



% Mela
% figure('Position', [1986 569 1717 420]); 
figure
s = 1;
% fig(s) = figure('Position', [1990 420 560 420]); 
axPSD(s) = subplot(1,3,s);
hold on
nSegs = length(psdDispM);
% cM = flipud(parula(nSegs));
cM = parula(nSegs);
for iSeg = 1:nSegs
    psd = psdDispM{iSeg};
%     psd = smooth(psdDispM{iSeg}, 5);
    plot3(fM, ones(length(psd), 1) * (tmidM(iSeg)), smooth(psdDispM{iSeg}, sm), ...
        'LineWidth', linWid, 'Color', cM(iSeg,:));
    
end
xlabel('Frequency (Hz)')
% ylabel('Time (minutes)')
title('S1 (Mela)')


% Kiwi
% figure('Position', [1986 569 1717 420]); 
figure

s = 2;
% fig(s) = figure('Position', [2553 420 560 420]); 
axPSD(s) = subplot(1,3,s);
hold on
nSegs = length(psdDispK);
% cK = flipud(parula(nSegs));
cK = parula(nSegs);
for iSeg = 1:nSegs
    psd = psdDispK{iSeg};
%     psd = smooth(psdDispK{iSeg}, 5);
    plot3(fK, ones(length(psd), 1) * (tmidK(iSeg)), smooth(psdDispK{iSeg}, sm), ...
        'LineWidth', linWid, 'Color', cK(iSeg,:));
    
end
xlabel('Frequency (Hz)')
% ylabel('Time (minutes)')
title('S2 (Kiwi)')


% Uva
figure('Position', [1986 569 1717 420]); 
% figure

s = 3;
% fig(s) = figure('Position', [3115 420 560 420]); 
axPSD(s) = subplot(1,3,s);
% axPSD(s) = axes;

hold on
nSegs = length(psdDispU);
% cU = flipud(parula(nSegs));
cU = parula(nSegs);
for iSeg = 2:2:nSegs
    psd = psdDispU{iSeg};
%     psd = smooth(psdDispU{iSeg}, 5);
    plot3(fU, ones(length(psd), 1) * (tmidU(iSeg)), smooth(psdDispU{iSeg}, sm), ...
        'LineWidth', linWid, 'Color', cU(iSeg,:));
    
end
xlabel('Frequency (Hz)')
% ylabel('Time (minutes)')
title('S3 (Uva)')


set(axPSD(:), 'XLim', freqLim, 'View', view3d, ...
    'ZTickLabel', [], 'ZTick', [], ...
    'YLim', [-10 150])


set(axFpks(:), 'XLim', [-10 150], 'YLim', [0 25])
for i = 1:length(axFpks)
    plot(axFpks(i), [0 0], [0 25], 'r', 'LineWidth', harLineWidth);
    
end



%%

fig2 = figure('Position', [1979 58 1717 420]);
view3d = [0 0];
freqLim = [0 25];
linWid = 1.0;
sm = 3;

% Mela
% figure('Position', [1986 569 1717 420]); 
figure

s = 1;
% fig(s) = figure('Position', [1990 420 560 420]); 
axPSD(s) = subplot(1,3,s);
hold on
nSegs = length(psdDispM);
% cM = flipud(parula(nSegs));
cM = parula(nSegs);
for iSeg = 1:nSegs
    psd = psdDispM{iSeg};
%     psd = smooth(psdDispM{iSeg}, 5);
    plot3(fM, ones(length(psd), 1) * (tmidM(iSeg)), smooth(psdDispM{iSeg}, sm), ...
        'LineWidth', linWid, 'Color', cM(iSeg,:));
    
end
xlabel('Frequency (Hz)')
% ylabel('Time (minutes)')
title('S1 (Mela)')


% Kiwi
% figure('Position', [1986 569 1717 420]); 
figure

s = 2;
% fig(s) = figure('Position', [2553 420 560 420]); 
axPSD(s) = subplot(1,3,s);
hold on
nSegs = length(psdDispK);
% cK = flipud(parula(nSegs));
cK = parula(nSegs);
for iSeg = 1:nSegs
    psd = psdDispK{iSeg};
%     psd = smooth(psdDispK{iSeg}, 5);
    plot3(fK, ones(length(psd), 1) * (tmidK(iSeg)), smooth(psdDispK{iSeg}, sm), ...
        'LineWidth', linWid, 'Color', cK(iSeg,:));
    
end
xlabel('Frequency (Hz)')
% ylabel('Time (minutes)')
title('S2 (Kiwi)')


% Uva
% figure('Position', [1986 569 1717 420]); 
figure

s = 3;
% fig(s) = figure('Position', [3115 420 560 420]); 
% axPSD(s) = subplot(1,3,s);
axPSD(s) = subplot(1,3,s);

hold on
nSegs = length(psdDispU);
% cU = flipud(parula(nSegs));
cU = parula(nSegs);
for iSeg = 1:2:nSegs
    psd = psdDispU{iSeg};
%     psd = smooth(psdDispU{iSeg}, 5);
    plot3(fU, ones(length(psd), 1) * (tmidU(iSeg)), smooth(psdDispU{iSeg}, sm), ...
        'LineWidth', linWid, 'Color', cU(iSeg,:));
    
end
xlabel('Frequency (Hz)')
% ylabel('Time (minutes)')
title('S3 (Uva)')


set(axPSD(:), 'XLim', freqLim, 'View', view3d, ...
    'ZTickLabel', [], 'ZTick', [], ...
    'YLim', [-10 150])



%% SUB-FUNCTIONS

function i_acc3Clean = exciseArts_dataSegment(acc3, i_tst, intervArt)
% mark all data within interval as NaN
% i_acc3 = accSeg{iSeg};
% i_tst = tstSeg{iSeg};
% figure; plot(i_tst, i_acc3)

% check all artifact intervals for "bad" timestamps
nArts = length(intervArt);
isArtTst = false(length(i_tst), 1);
for iArt = 1:nArts
    isArt = (i_tst >= intervArt(iArt,1)) & (i_tst < intervArt(iArt,2));
    isArtTst = isArt | isArtTst; % update for each artifact 
    
end
i_acc3 = acc3;
i_acc3(isArtTst,:) = NaN;
% figure; plot(i_tst, i_acc3)


% stictch good data (one channel at a time)
nChs = size(i_acc3, 2);
for iCh = 1:nChs
    i_acc = i_acc3(:,iCh);
    
    [start, len, k1] = ZeroOnesCount(~isArtTst);
    
    % gather good subsegments of the data into separate cells
    for ik = 1:k1
        begIdx = start(ik);
        endIdx = start(ik) + len(ik) - 1;
        dataGood{ik} = i_acc(begIdx:endIdx);
        
    end
    
    % Stitching back together: starting at the first data segment, 
    % concatenate the next segment to the first after offsetting the new
    % segment so that the last and first samples match. 
    i_accClean = detrend(dataGood{1});
    for ik = 2:k1
%         offset = dataGood{ik-1}(end) - dataGood{ik}(1);
%         i_accClean = [i_accClean; (dataGood{ik} + offset)]; % concatenate
        i_accClean = [i_accClean; detrend(dataGood{ik})]; % concatenate

               
    end
    
    
    % Add the clean results into the new clean acc3
    i_acc3Clean(:,iCh) = i_accClean;
   
    
end
% 
%  f1 = figure('Position', [2094 301 560 420]);
%     plot(i_acc3Clean);
%     close(f1)


end

function [start, len, k1] = ZeroOnesCount(v)
%
% Determine the position and length of each 1-string in v,
% where v is a vector of 1s and 0s
% Derek O'Connor 21 Sep 2011
%
 n = length(v);
 start = zeros(1,n);            % where each 1-string starts
 len = zeros(1,n);              % length of each 1-string
 k1= 0;                         % count of 1-strings
 inOnes = false;
 for k = 1:n
     if v(k) == 0               % not in 1-string
         inOnes = false;
     elseif ~inOnes             % start of new 1-string
         inOnes = true;
         k1 = k1+1;
         start(k1) = k;
         len(k1) = 1;
     else                       % still in 1-string
         len(k1) = len(k1)+1;
     end
 end
 
 
end

function plot_psdFpksSegs_vs_tmid(tmidM, psdFpksSegsM, pcoeff)
scatSz = 30;
scatC = 'k'; 
pchipLineStyle = '--';


grid on; hold on;
xqM = tmidM(1):0.1:tmidM(end);
yyM = pchip(tmidM, psdFpksSegsM, xqM);
% pM = plot(xqM, yyM, 'LineStyle', pchipLineStyle, 'Color', linC_M);
pM = plot(xqM, yyM, 'LineStyle', pchipLineStyle);

scatter(tmidM, psdFpksSegsM, scatSz, scatC, 'filled');

% plot additional linear fit line
if exist('pcoeff', 'var')
    hold on; plot([0 150], polyval(pcoeff, [0 150]));
    
end

end

function tmidM = get_tmidSegHarRef(tstSeg, nwbM)
% Get time midpoints of each data segmetn, corrected for time since
% harmaline injection
% Adjust timestamps to reflect harmaline injection time (t = 0)
dstr = datestr(nwbM.timestamps_reference_time);
startDT = datetime(dstr(end-7:end));
harStr = nwbM.general_notes(end-7:end);
harDT = datetime(nwbM.general_notes(end-7:end));
harRefSec = seconds(harDT - startDT);
nSegs = length(tstSeg);

for iSeg = 1:nSegs
    tstSegHarRef{iSeg,1} = tstSeg{iSeg} - harRefSec;
%     TSTcleanCell{iSeg} = TSTcleanCell{iSeg} - harRefSec;
    
% end

% for iSeg = 1:nSegs
    % get time span for each segment, time midpoint
    iTst = tstSegHarRef{iSeg};
    tspan(iSeg) = iTst(end) - iTst(1);
    tmidM(iSeg) = (iTst(end) + iTst(1)) / 2;
    
end

% % convert from seconds to minutes
% tmidM = tmidM / 60;
% tspan = tspan / 60;

end

function [acc, tst, ctrl, fs] =  getACCprocData(nwbM)
accTseriesObj = nwbM.processing.get('ACCproc').deref().nwbdatainterface.get('ACCproc');

% accTseriesObj = nwb.processing.get('ACCproc').deref();


% load just the accelerometry data
dims = accTseriesObj.data.dims;
acc = accTseriesObj.data.load([1, 1], [dims(1), 3]);
tst = accTseriesObj.timestamps.load;
ctrl = accTseriesObj.control.load;
fs = accTseriesObj.starting_time_rate;


end

function [pxx, f, pxxc] = getPSDdataSeg(acc3, window, noverlap, nfft, fs)
% first detrend and de-stutter the data by bandpass filtering
for i = 1:3
    acc3Detr(:,i) = detrend(acc3(:,i)); 
    
end
[b,a] = butter(1, [1 50] / (fs/2), 'bandpass');
acc3Filt = filtfilt(b, a, acc3Detr);


% Get PSD from one segment at a time
% acc3 = accSeg{iSeg};
% t = (1/fs) * (0:(length(acc3)-1));
[pxx, f, pxxc] = pwelch(acc3Filt, window, noverlap, nfft, fs);
% figure; plot(f, pxx);
% set(gca, 'XLim', [0 35])
end

function [psdFpksSegsM, psdPpksSegsM] = getSegmentPSDpeaks(psdSegsM, fSegsM, fspan)

% Get frequency peaks for each data segment
% fspan = [0 35];
nSegs = length(psdSegsM);
for iSeg = 1:nSegs
    % Specify subselection of frequencies to look at
%     SegF = fSegsM{iSeg,1};
    SegF = fSegsM;

    isRange = (SegF >= fspan(1)) & (SegF < fspan(2));
    SegFsub = SegF(isRange);
    
    
    % Get frequency peaks
    SegPSDs = psdSegsM{iSeg,1}(isRange,:);
    nPSDs = size(SegPSDs, 2);
    for iPSD = 1:nPSDs
        Ppk(iPSD) = max(SegPSDs(:,iPSD));
        Fpk(iPSD) = SegFsub(SegPSDs(:,iPSD) == Ppk(iPSD));
        
    end
    
    psdPpksSegsM(iSeg,1) = Ppk;
    psdFpksSegsM(iSeg,1) = Fpk;
    
    
end



end

function [powComp] = comparePow(tremPowM, notremPowM)

nSegs = length(tremPowM);
for iSeg = 1:nSegs
    powComp{iSeg,1} = tremPowM{iSeg} ./ notremPowM{iSeg};
    
end

end


function [accSegFinal, tstSegFinal] = segmentacc(acc, tst, ctrl, maxSamp)
% separate acc data and timestamps into time segments based on recordings.
% Large recordings are further subdivided into smaller time segements according
% to max segment time. maxTime (seconds). ctrl has zero at the start of
% every recording. 

% for acc and tst composed of N separate recordings, ctrl tracks which data
% belongs to which N recording

% detect the number of segments
nSegs = max(ctrl);
for iSeg = 1:nSegs
    accSeg{iSeg,1} = acc((ctrl == iSeg),1:3);
    tstSeg{iSeg,1} = tst((ctrl == iSeg));
    nSamps(iSeg) = sum(ctrl == iSeg);
    
end

% If any segments are too long according to maxSamp 
accSegFinal = {};
tstSegFinal = {};
if exist('maxSamp', 'var')
    for iSeg = 1:nSegs
        if nSamps(iSeg) > maxSamp % Too big! subdivide the segment into smaller ones
            nSubs = floor(nSamps(iSeg)/maxSamp) + 1;
            tempAcc = accSeg{iSeg,1};
            tempTst = tstSeg{iSeg,1};
            
            % mark subdivisions with indices
            xb = 1:(nSubs-1);
            bIdx = [1, xb*maxSamp + 1];
            eIdx = [xb*maxSamp, nSamps(iSeg)];
            
            % loop-fill the new subsections to be added
            for iSub = 1:nSubs
                accSegFinal = [accSegFinal; {tempAcc(bIdx(iSub):eIdx(iSub),1:3)}];
                tstSegFinal = [tstSegFinal; {tempTst(bIdx(iSub):eIdx(iSub))}];
                
            end
            
%             xb = [1:nRowsAdd]';
% 
%             % begIdxCorr
%             begIdxSmall = begIdx(i) + xb*maxSamp + 1;
%             begIdxCorr = [begIdxCorr; begIdx(i); begIdxSmall];
% 
%             % endIdxCorr
%             endIdxSmall = begIdx(i) + xb*maxSamp;
%             endIdxCorr = [endIdxCorr; endIdxSmall; endIdx(i)];

        else
            accSegFinal = [accSegFinal; accSeg(iSeg,1)];
            tstSegFinal = [tstSegFinal; tstSeg(iSeg,1)];
        
        end
    
        
        
    end
    
else % simple case where maxSamp is not entered into the function, no subdivision done
    accSegFinal = accSeg;
    tstSegFinal = tstSeg;
    
end




% 
% 
% begIdx = find(ctrl == 0);
% endIdx = [(begIdx(2:end)-1); length(ctrl)];
% % nSamps = diff([begIdx endIdx], [], 2);
% 
% % enforce maximum samples for each segment
% % isToobig = nSamps > maxSamp;
% nSamps = diff([begIdx endIdx], [], 2);
% begIdxCorr = [];
% endIdxCorr = [];
% for i = 1:length(begIdx)
% 
%     if diff([begIdx(i) endIdx(i)], [], 2) > maxSamp % Too big! break up the segment into smaller ones
%         nRowsAdd = floor(nSamps(i)/maxSamp); 
%         xb = [1:nRowsAdd]';
%         
%         % begIdxCorr
%         begIdxSmall = begIdx(i) + xb*maxSamp + 1;
%         begIdxCorr = [begIdxCorr; begIdx(i); begIdxSmall];
%         
%         % endIdxCorr
%         endIdxSmall = begIdx(i) + xb*maxSamp;
%         endIdxCorr = [endIdxCorr; endIdxSmall; endIdx(i)];
%         
%     else
%         begIdxCorr = [begIdxCorr; begIdx(i)];
%         endIdxCorr = [endIdxCorr; endIdx(i)];
%         
%     end
%     
%     
%     
% end


% Gather data segments
% nSegs = length(begIdxCorr);
% for iSeg = 1:nSegs
%     accSeg{iSeg,1} = acc(begIdxCorr(iSeg):endIdxCorr(iSeg),:);
%     tstSeg{iSeg,1} = tst(begIdxCorr(iSeg):endIdxCorr(iSeg),:);
%     
% end


end

function [accProc, tstProc] = fillACC(acc, tst, ctrl, fs)
% pre-process acc data so that missing values are interpolated and
% inter-file spaces are NaNs spaced out according to common
% sampling-frequency of all files in session
% ctrl goes from 0 to N for a single file of N samples (some may be
% missing). For an NWB file where multiple files were concatenated, the 0
% to N ctrl count will reset and start again from 0 at the startint point
% of the next file. 


Ts = 1/fs;                           % Sampling Time
% tst = [0:10  14:20  25:30]*0.00274;       % Create Time Series With Gaps
% acc = rand(size(tst));                      % Create Matching Data
tst = tst';
tn = round(tst/Ts);                       % Create Indices With Gaps
dt = diff([0 tn]);                      % Create Vector Of Differences
tg = find(dt > 1);                      % Find Indices Of Gaps
gaps = dt(tg)-1;                        % Find Lengths Of Gaps
ti = linspace(min(tst),max(tst),max(tn));   % Create Continuous Time Vector
fi = interp1(tst,acc,ti);                   % Create Matching Data Vector
for k1 = 1:length(tg)                   % Loop Filling Gaps In ‘f’ With NaN
    q = [tg(k1):tg(k1)+gaps(k1)-1];
    fi(tg(k1):tg(k1)+gaps(k1)-2) = nan(1,gaps(k1)-1);
end


% First subdivide 




nCtrls = length(ctrl);
for ictrl = 1:nCtrls
    
    
end

% then interpolate any short missing values within recordings


end

function [Sacc, f, tSpec] = spectrogramacc3(acc, fs, cfg)

% Detrend data, linear best fit is subtracted from each channel
acc = detrend(acc);


% Highpass filter out slow components

[b,a] = butter(3, cfg.fcDetrend/(fs/2), 'high');
accFilt = filtfilt(b, a, acc);



%% Get combined triaxial spectrogram

window = floor(cfg.TWIN * fs);

% Sum PSDs from all 3 accel channels
clear Z S
for ch = 1:3
    [Z(:,:,ch), f, tSpec] = spectrogram(accFilt(:,ch), window, cfg.NOVERLAP, [], fs, 'yaxis');
    % tRef = linspace(tSpec(1), tSpec(end), numel(tSpec));
    S(:,:,ch) = abs(Z(:,:,ch));
    S(:,:,ch) = S(:,:,ch).^2;

end
% Combine spectral power from all three axes (summate)
Sacc = sum(S, 3);

end

function ScleanCell = removeMovArtInAll(SaccCell, cfg)
% First concatenate all segments spectrograms together and keep track of
% their place within segment cells
nSegs = length(SaccCell);
SaccAll = [];
origIdx = [];
for iSeg = 1:nSegs
    iSacc = SaccCell{iSeg,1};
    origIdx = [origIdx, 1:size(iSacc, 2)]; % keeps tabls of time windows in spectrograms
    SaccAll = [SaccAll, SaccCell{iSeg,1}];   
    
end


% Identify movement artifact windows in spectrogram

[~, isMovArt] = util.remoutliers(sum(SaccAll, 1), ...
    'bound', 'upper', ...
    'MADthresh', cfg.MADthresh);
temp = SaccAll;
temp(:,isMovArt) = NaN;
SaccMarkOutliers = SaccAll;
SaccMarkOutliers(:,isMovArt) = NaN;


% Show Spectrogram with detected movement artifacts marked as 100's values
if cfg.displayWorkflowFigs
    f4 = figure;
    ax4 = axes;
    ax4.Parent = f4;
    surf(tSpec, f, 10*log10(SaccMarkOutliers), ...
        'Parent', ax4, ...
        'EdgeColor', 'none');
    hold(ax4, 'on');
    xlabel('Time (min)');
    grid on
    axis(ax4, 'tight')
    view(0,90)
    colorbar
    % ax4.YLim = [0, 300];
    % ax4.CLim = [-80, -30];
    title('Mov Artifacts marked');
    ylabel('Frequency (Hz)');
    f4.Position = [2555 57 560 421];

end

% Show Spectrogram with movement artifacts removed totally
if cfg.displayWorkflowFigs
    f4 = figure;
    ax4 = axes;
    ax4.Parent = f4;
%     tset = t;
%     tset(isMovArt) = [];
    surf(1:size(temp, 2), f, 10*log10(temp), ...
        'Parent', ax4, ...
        'EdgeColor', 'none');
    hold(ax4, 'on');
    xlabel('samples');
    grid on
    axis(ax4, 'tight')
    view(0,90)
    colorbar
    ax4.YLim = [0, 150];
    % ax4.CLim = [-80, -30];
    title('Mov Artifacts removed')
    ylabel('Frequency (Hz)');
    f4.Position = [2554 566 560 420];

end


% Get average PSD free of movement artifact windows
ScleanAll = temp; % movement artifact windows removed
% PSD = mean(ScleanAll, 2);
if cfg.displayWorkflowFigs
    f1 = figure; ax = axes;
    plot(f, (PSD));
    grid on; 
    ax.XLim = [0, 35];
    %     ax.YLim = [0, popMaxPSD];
    xlabel('Frequency (Hz)');
%     title(['Minutes since harmaline inject: ' num2str(minutes(sessTabRow.harRefTime(1)))], 'Interpreter', 'none')

end


% Output nan-marked spectrograms back in their original cells
begIdx = find(origIdx == 1);
endIdx = [(begIdx(2:end)-1), size(ScleanAll, 2)];
for iSeg = 1:nSegs
    ScleanCell{iSeg,1} = ScleanAll(:,(begIdx(iSeg):endIdx(iSeg)));
    
end

% Remove nan-marked columns in each spectrogram (pertaining to time-window
% labeled as movemend artifact) for each segment
for iSeg = 1:nSegs
    iSaccnan = ScleanCell{iSeg,1};
    nanIdx = isnan(sum(iSaccnan, 1));
    iSaccClean = iSaccnan;
    iSaccClean(:,nanIdx) = [];
    
    ScleanCell{iSeg,1} = iSaccClean;
    
end



end