% script to mess with hilbert shenanigans in Kiwi's data, based on
% "script_kiwiTremor_PSDs.m"


% Collected on microstrain G-link hardware
clear; close all

% % G-link sampling freq when streaming 3 channels (hardware design)
% fs = 617; % samples/second
% 
% dataAcqPn = 'D:\PROJECTS\Thalamic DBS for Harmaline Tremors\Data Acquisition\';
% directoryPn = 'Mela\Harmaline\';
% projRootPath = 'L:\My Drive\PROJECTS\Thalamic DBS for Harmaline Tremors\';
% SavePn = 'Data Processing\Mela_tremors\';
% 


projRootPath = 'L:\My Drive\PROJECTS\Thalamic DBS for Harmaline Tremors\';

% for loading
dataAcqPn = 'L:\My Drive\PROJECTS\Thalamic DBS for Harmaline Tremors\';
directoryPn = 'Data Acquisition\Kiwi Experiment\';
inputMetaData = 'RecordingsMetadata_selectDisplay.mat';


% CONSTANTS

% decide whether to show all figures generated by workflow
cfg.displayWorkflowFigs = false;

% (the the rest of the constants See inside "tremorWorkflow" function at bottom of script)

cfg.fcDetrend = 1; % Hz

% Spectrogram parameters:
cfg.TWIN = 1; % seconds, sliding time-window of spectrogram
cfg.NOVERLAP = 0; % samples, no overlaps for these spectrogam windows

% Movement artifact removal
cfg.MADthresh = 2; % median limit for outliers

% Tremor frequency band
% trPeak = 15; % Hz, major tremor component
% trRange = 3; % limits of tremor band around major component
cfg.lowBand = [3 9]; % Hz
cfg.highBand = [12 16];

% General movement frequency band
cfg.generalBand = [1, 35];

% Downsampling high sampling frequency files from ~8kHz down to ~512 Hz, to
% be near in sampling frequency to the 500 Hz sampling frequency files:
cfg.DWNFACTOR = 16;



%% Load metadata for all files

% pre-load the metadata table with file info
load([projRootPath 'Data Acquisition\Kiwi Experiment\' inputMetaData], 'Tselect');
fullMeta = Tselect;


% % Read in metadata table for Mela's recordings
% tablePath = 'Data Acquisition\Mela Experiment\';
% metaTab = readtable([projRootPath tablePath 'acquisitionMetadata_Mela.csv']);
% harTab = readtable([projRootPath tablePath 'harmalineSessionData.csv']);
% fullMeta = join(metaTab, harTab);

% % add in data for time since harmaline injection
% harRefTime = fullMeta.startTime - fullMeta.harInjTime;
% fullMeta = [fullMeta, table(harRefTime)];



%% Perform processing from Session 1 only
% Loop thru all individual files adding values to table

% Sess1 = fullMeta(fullMeta.session == 1,:);
Sess1 = fullMeta;
nRows = height(Sess1);

tic
for iRow = 1:nRows
    
    sessTabRow = Sess1(iRow,:);
    [fPeakTr(iRow,1), aTremorPow(iRow,1), ...
        aPowRatio(iRow,1)] = tremorWorkflow(sessTabRow, ...
        dataAcqPn, directoryPn, cfg);
   
end
toc

Sess1 = [Sess1, table(fPeakTr), table(aTremorPow), table(aPowRatio)];

close all
clear fPeakTr aTremorPow aPowRatio accTrMagSum


% 
% %% Perform processing from Session 2 only
% % Loop thru all individual files adding values to table
% 
% Sess2 = fullMeta(fullMeta.session == 2,:);
% nRows = height(Sess2);
% 
% tic
% for iRow = 1:nRows
%     
%      sessTabRow = Sess2(iRow,:);
%     [fPeakTr(iRow,1), aTremorPow(iRow,1), ...
%         aPowRatio(iRow,1)] = tremorWorkflow(sessTabRow, ...
%         dataAcqPn, directoryPn, cfg);
%         
% end
% toc
% 
% Sess2 = [Sess2, table(fPeakTr), table(aTremorPow), table(aPowRatio)];
% 
% close all
% clear fPeakTr aTremorPow aPowRatio accTrMagSum
% 
% 
% 
% %% Perform processing from Session 3 only
% % Loop thru all individual files adding values to table
% 
% Sess3 = fullMeta(fullMeta.session == 3,:);
% nRows = height(Sess3);
% 
% tic
% for iRow = 1:nRows
%     
%      sessTabRow = Sess3(iRow,:);
%     [fPeakTr(iRow,1), aTremorPow(iRow,1), ...
%         aPowRatio(iRow,1)] = tremorWorkflow(sessTabRow, ...
%         dataAcqPn, directoryPn, cfg);
%        
% end
% toc
% 
% Sess3 = [Sess3, table(fPeakTr), table(aTremorPow), table(aPowRatio)];
% 
% close all
% clear fPeakTr aTremorPow aPowRatio accTrMagSum


%% Obtain specific pairs of accelerometry PSDs that exemplify the trend for each day

% For Session 1
% sessTabs{1} = Sess1;
% sessTabs{2} = Sess2;
% sessTabs{3} = Sess3;
% 
dispRec = [1 7 13];
% 
% for iSess = 1:3
%     
%     % specify current table
%     SessN = Sess1;
%     
%     % fill in frequency and PSD details
%     fn = SessN.filename{dispRec(1)};
%     fs = SessN.samplingFrequency(1);
%     dataTab = readtable([dataAcqPn directoryPn fn]);
%     acc = [dataTab.Channel1, dataTab.Channel2, dataTab.Channel3];
% 
%     [frec{iSess,1},PSDrec{iSess,1}] = getCleanPSD(acc, fs, cfg);
%     
    



for ex = 1:3
    % Load in data and get into format of "acc" and "fs"
    fn = Sess1.filename{dispRec(ex)};
    load([dataAcqPn directoryPn fn], ...
        'data', 'time', 'sampling_frequency', 'output_signal');
    % if it's a stim recording, the first channel will be a recording of TACS
    % or DBS signal, for a total of 4 channels; otherwise there should just be
    % 3 channels of accel
    if size(data, 2) == 4 
        acc = data(:,2:4);

    else
        acc = data(:,1:3);

    end
    t = time;
    fs = sampling_frequency;

    [frec{ex},PSDrec{ex}] = getCleanPSD(acc, fs, cfg);
    
end

    

    
    
    

%     fn = SessN.filename{dispRec(iSess,2)};
%     fs = SessN.samplingFrequency(end);
%     dataTab = readtable([dataAcqPn directoryPn fn]);
%     acc = [dataTab.Channel1, dataTab.Channel2, dataTab.Channel3];
% 
%     [frec{iSess,2},PSDrec{iSess,2}] = getCleanPSD(acc, fs, cfg);
% 
%     
% end



%% Display Peak frequency over time


figure('Position', [1958 167 1811 805]);



% Session 1: 2 mg/kg
tSinceHar = minutes(Sess1.harRefTime(:)); % minutes
sess = 1;

ex = 1;
ax(1) = subplot(2,3,1); plot(frec{ex}, PSDrec{ex}); 
xlabel('Frequency (Hz)'); ylabel('acc PSD'); 
title('immediately post harmaline'); grid on; hold on;

ex = 2;
ax(2) = subplot(2,3,2); plot(frec{ex}, PSDrec{ex}); 
xlabel('Frequency (Hz)'); ylabel('acc PSD'); 
title('40 min post'); grid on; hold on;

ex = 3;
ax(3) = subplot(2,3,3); plot(frec{ex}, PSDrec{ex}); 
xlabel('Frequency (Hz)'); ylabel('acc PSD'); 
title('90 min post'); grid on; hold on;



ax(4) = subplot(2,3,4); stem(tSinceHar, Sess1.aTremorPow);
xlabel('Time since injection (mins)'); ylabel('Power, A.U.'); 
title('Tremor band power'); grid on; hold on;

ax(5) = subplot(2,3,5); stem(tSinceHar, 100*(Sess1.aPowRatio));
xlabel('Time since injection (mins)'); ylabel('Tremor/Mov %'); 
title('% acc Power'); grid on; hold on;


% % Session 2: 6 mg/kg
% tSinceHar = minutes(Sess2.harRefTime(:)); % minutes
% sess = 2;
% 
% ax(4) = subplot(3,3,4); plot(frec{sess,1}, PSDrec{sess,1}, frec{sess,2}, PSDrec{sess,2}); 
% xlabel('Frequency (Hz)'); ylabel('acc PSD'); legend('preHarmaline', '30 min post')
% title('First and last recording '); grid on; hold on;
% 
% ax(5) = subplot(3,3,5); stem(tSinceHar, Sess2.aTremorPow);
% xlabel('Time since injection (mins)'); ylabel('Power, A.U.'); 
% title('Tremor band power'); grid on; hold on;
% 
% ax(6) = subplot(3,3,6); stem(tSinceHar, 100*(Sess2.aPowRatio));
% xlabel('Time since injection (mins)'); ylabel('Tremor/Mov %'); 
% title('% acc Power'); grid on; hold on;
% 
% 
% % Session 3: 12 mg/kg
% tSinceHar = minutes(Sess3.harRefTime(:)); % minutes
% sess = 3;
% 
% ax(7) = subplot(3,3,7); plot(frec{sess,1}, PSDrec{sess,1}, frec{sess,2}, PSDrec{sess,2}); 
% xlabel('Frequency (Hz)'); ylabel('acc PSD'); legend('preHarmaline', '30 min post')
% title('First and last recording '); grid on; hold on;
% 
% ax(8) = subplot(3,3,8); stem(tSinceHar, Sess3.aTremorPow);
% xlabel('Time since injection (mins)'); ylabel('Power, A.U.'); 
% title('Tremor band power'); grid on; hold on;
% 
% ax(9) = subplot(3,3,9); stem(tSinceHar, 100*(Sess3.aPowRatio));
% xlabel('Time since injection (mins)'); ylabel('Tremor/Mov %'); 
% title('% acc Power'); grid on; hold on;


timeAxes = [4 5];
psdAxes = [1 2 3];
powerAxes = [4];
ratioAxes = [5];



% Adjust some group scaling
set(ax(powerAxes), 'YLim', [0 250]);
set(ax(ratioAxes), 'YLim', [0 100]);

% Adjust time window shown
set(ax(timeAxes), 'XLim', [0 150]);

% Adjust frequency lims
% set(ax(psdAxes), 'XLim', [0 35]);
set(ax(psdAxes), 'XLim', [0 35], 'YLim', [0 20]);


% % last min touches
% ax(1).YLim = [0 12e5];
% ax(7).YLim = [0 12e5];


% Add a red line showing time of harmaline inject to all plots
for i = timeAxes
    plot(ax(i), [0, 0], [ax(i).YLim], 'r');
    
end


%% SUB-FUNCTIONS

function [fPeakTr,aTremorPow,aPowRatio] = tremorWorkflow(sessTabRow, dataAcqPn, directoryPn, cfg)
% runs the whole workflow to obtain spectrogram and tremor power outputs
% input is a single row of the table that is being referenced

% % Load in data and get into format of "acc" and "fs"
% fn = sessTabRow.filename{1};
% dataTab = readtable([dataAcqPn directoryPn fn]);

% Load in data and get into format of "acc" and "fs"
fn = sessTabRow.filename{1};
load([dataAcqPn directoryPn fn], ...
    'data', 'time', 'sampling_frequency', 'output_signal');


% if it's a stim recording, the first channel will be a recording of TACS
% or DBS signal, for a total of 4 channels; otherwise there should just be
% 3 channels of accel
if size(data, 2) == 4 
    acc = data(:,2:4);

else
    acc = data(:,1:3);

end
t = time;
fs = sampling_frequency;

%%

% Detrend data, linear best fit is subtracted from each channel
acc = detrend(acc);


% Highpass filter out slow components
% fc = 1; % Hz
[b,a] = butter(3, cfg.fcDetrend/(fs/2), 'high');
accDetrend = filtfilt(b, a, acc);

% Because of stupidity I recorded things at two different sampling
% frequencies. Now, PSD peak amplitudes are significantly affected by 
% sampling frequency, so to properly compare data recorded with
% different fs we need to downsample the faster one to get as close to
% the slower as possible. 

% two frequencies used: 500 Hz, 8,193.4 Hz
if fs > 500
%     DWNFACTOR = 16;
    fs = fs/cfg.DWNFACTOR; % bring down to 512.0852
%     t = downsample(t, cfg.DWNFACTOR);
    clear y
    for i = 1:3
        y(:,i) = decimate(accDetrend(:,i), cfg.DWNFACTOR);

    end
    accDetrend = y;

else
%     dTime = t;
end



%%




% Custom Sub-function:
[f,PSD,tSpec,isMovArt] = getCleanPSD(accDetrend, fs, cfg);


% TRACK peak frequency results for table
fPeakTr = f(PSD == max(PSD));

% TRACK sum of tremor power
isLoBand = (f >= cfg.lowBand(1)) & (f < cfg.lowBand(2));
isHiBand = (f >= cfg.highBand(1)) & (f < cfg.highBand(2));
isTremor = isLoBand | isHiBand;
aTremorPow = sum(PSD(isTremor));



% Get Ratio of tremor power vs general movmement power
% Use a log-tranformed PSD power

% TRACK sum of tremor power
isGenMov = (f >= cfg.generalBand(1)) & (f < cfg.generalBand(2));
aGenPow = sum(PSD(isGenMov));

% Mean Power for total time
aPowRatio = aTremorPow / aGenPow;


%% Section for comparing cross-correlation among hilbert magnitude envelopes

% Split time-series data into two bands

% binsPerDecade = 2;
% nBins = 40;
% binEdgeLeft = 10^(0);
% binEdges = binEdgeLeft*10.^((0:nBins)/binsPerDecade)

% fcLo = [3.1623, 10]; % Hz
% fcHi = [10, 31.6228]; % Hz 

% Low band: 
[b, a] = butter(2, cfg.lowBand / (fs/2), 'bandpass');
accLo = filtfilt(b, a, accDetrend);

% High band:
[b, a] = butter(2, cfg.highBand / (fs/2), 'bandpass');
accHi = filtfilt(b, a, accDetrend);



% % Get PSD estimates for both bands as above
% 
% % LOW-BAND
% window = floor(TWIN * fs);
% clear Z S
% for ch = 1:3
%     [Z(:,:,ch), f, tSpec] = spectrogram(accLo(:,ch), window, NOVERLAP, [], fs, 'yaxis');
%     % tRef = linspace(tSpec(1), tSpec(end), numel(tSpec));
%     S(:,:,ch) = abs(Z(:,:,ch));
%     S(:,:,ch) = S(:,:,ch).^2;
% 
% end
% SaccLo = sum(S, 3);
% SaccLoClean = SaccLo;
% SaccLoClean(:,isMovArt) = [];
% PSDlo = mean(SaccLoClean, 2);
% % figure; plot(f, 10*log10(PSDlo));
% 
% 
% % HIGH-BAND
% window = floor(TWIN * fs);
% clear Z S
% for ch = 1:3
%     [Z(:,:,ch), f, tSpec] = spectrogram(accHi(:,ch), window, NOVERLAP, [], fs, 'yaxis');
%     % tRef = linspace(tSpec(1), tSpec(end), numel(tSpec));
%     S(:,:,ch) = abs(Z(:,:,ch));
%     S(:,:,ch) = S(:,:,ch).^2;
% 
% end
% SaccHi = sum(S, 3);
% SaccHiClean = SaccHi;
% SaccHiClean(:,isMovArt) = [];
% PSDhi = mean(SaccHiClean, 2);
% % figure; plot(f, 10*log10(PSDhi));
% tSpec = tSpec';
% 
% % TRACK peak frequency results for table
% fPeakLo(iRow,1) = f(PSDlo == max(PSDlo));
% fPeakHi(iRow,1) = f(PSDhi == max(PSDhi));
% 
% % TRACK PSD peak amplitudes for each band too
% aPeakLo(iRow,1) = max(PSDlo);
% aPeakHi(iRow,1) = max(PSDhi);



% Get hilbert instantaneous band power for lo and hi

accLoMag = abs(hilbert(accLo));
% accLoPha = angle(hilbert(accLo));
accHiMag = abs(hilbert(accHi)); 
% accHiPha = angle(hilbert(accHi)); 



% Remove data points pertaining to movment artifact time windows, detected
% from the Spectrogram work...

accLoMagSum = sum(accLoMag, 2);
accHiMagSum = sum(accHiMag, 2);

% Go from known mov artifact specgram time windows to labeling time-series
% indices to exclude from final analysis:

% specify m x n matrix to track which time-series samples to mark. m:
% samples in time-series; n: number of spectrogram windows detected as mov
% artifact

nArts = sum(isMovArt);
idxArt = find(isMovArt);
artWinIdx = false(length(accLoMag), sum(isMovArt));

for iArt = 1:nArts
    % specgram window time represents center of window
    i_timeArt = tSpec(idxArt(iArt));
    i_timeRange = [(i_timeArt - cfg.TWIN/2), (i_timeArt + cfg.TWIN/2)];

    % the values of time-series time that fall within this range will be
    % marked as artifact sample indices
    artWinIdx(:,iArt) = (t >= i_timeRange(1)) & (t < i_timeRange(2));

end
% Collapse all detected mov artifact indices to 1D to mark the samples in
% time-series that need to be ignored
isMovArtTimeSeries = any(artWinIdx, 2);

% figure; plot(accLoMagSum); hold on; plot(isMovArtTimeSeries);
% figure; plot(accHiMagSum); hold on; plot(isMovArtTimeSeries);

% Remove values that fall within movement artifact time
accLoMagSum(isMovArtTimeSeries) = [];
accHiMagSum(isMovArtTimeSeries) = [];



% Get average Power for each band, and TRACK

% Mean Power for total time
% avLoMag(iRow,1) = mean(accLoMagSum);
% avHiMag(iRow,1) = mean(accHiMagSum);

% x = accLoMagSum;
% y = accHiMagSum;

[R,Pc] = corrPermute(accLoMagSum, accHiMagSum)

% % Cross-correlation for 
% x = accLoMagSum;
% y = accHiMagSum;
% 
% [r, p] = corrcoef(x, y);
% R(iRow,1) = r(2);
% 
% x_boot = x;
% 
% 
% % get p-test based on this empirical bootstrapp'd distribution
% nBoots = 1000;
% nSamps = length(x);
% r_boot = zeros(nBoots, 1);
% for iBoot = 1:nBoots
%     x_boot = circshift(x, randi(nSamps));
%     rtemp = corrcoef(x_boot, y);
%     r_boot(iBoot) = rtemp(2);
% 
% end
% Pc(iRow,1) = sum(r_boot > R(iRow,1)) / numel(r_boot);

% figure; plot(x); hold on; plot(y); 
% title(['Pearson R: ' num2str(R) ', p = ' num2str(Pc)]); 
% legend('low band', 'high band')




end

function [f,PSD,tSpec,isMovArt] = getCleanPSD(accFilt, fs, cfg)
% runs the whole workflow to obtain spectrogram and tremor power outputs
% input is a single row of the table that is being referenced
% 
% INPUTS
% acc - triaxial accelerometer data, column oriented
%  fs - sampling freq of said accelerometer data
% cfg.
%     fcDetrend - highpass filter cutoff for detrending acc data (Hz)
%     TWIN - window to be used for spectrogram
%     NOVERLAP - samples of overlap for spectrogram windows
%     displayWorkflowFigs - TF value for whether or not to show figures of
%                           intermediate steps

   

%%


% % Load in data and get into format of "acc" and "fs"
% fn = sessTabRow.filename{1};
% dataTab = readtable([dataAcqPn directoryPn fn]);
% t = 1/fs * (0:(height(dataTab) - 1))';
% acc = [dataTab.Channel1, dataTab.Channel2, dataTab.Channel3];

% % Detrend data, linear best fit is subtracted from each channel
% acc = detrend(acc);
% 
% 
% % Highpass filter out slow components
% 
% [b,a] = butter(3, cfg.fcDetrend/(fs/2), 'high');
% accFilt = filtfilt(b, a, acc);

% % Detrend data, linear best fit is subtracted from each channel
% acc = detrend(acc);
% 
% 
% % Highpass filter out slow components
% % fc = 1; % Hz
% [b,a] = butter(3, cfg.fcDetrend/(fs/2), 'high');
% accFilt = filtfilt(b, a, acc);
% 
% % Because of stupidity I recorded things at two different sampling
% % frequencies. Now, PSD peak amplitudes are significantly affected by 
% % sampling frequency, so to properly compare data recorded with
% % different fs we need to downsample the faster one to get as close to
% % the slower as possible. 
% 
% % two frequencies used: 500 Hz, 8,193.4 Hz
% if fs > 500
% %     DWNFACTOR = 16;
%     fs = fs/cfg.DWNFACTOR; % bring down to 512.0852
% %     t = downsample(t, cfg.DWNFACTOR);
%     clear y
%     for i = 1:3
%         y(:,i) = decimate(accFilt(:,i), cfg.DWNFACTOR);
% 
%     end
%     accFilt = y;
% 
% else
% %     dTime = t;
% end



%% Get combined triaxial spectrogram

window = floor(cfg.TWIN * fs);

% Sum PSDs from all 3 accel channels
clear Z S
for ch = 1:3
    [Z(:,:,ch), f, tSpec] = spectrogram(accFilt(:,ch), window, cfg.NOVERLAP, [], fs, 'yaxis');
    % tRef = linspace(tSpec(1), tSpec(end), numel(tSpec));
    S(:,:,ch) = abs(Z(:,:,ch));
    S(:,:,ch) = S(:,:,ch).^2;

end
% Combine spectral power from all three axes (summate)
Sacc = sum(S, 3);

% Get average power (S) PSD over time
% PSDWashNorm = Swash ./ (repmat(PSDbaseAv, 1, size(Swash, 2)));
if cfg.displayWorkflowFigs
    f2 = figure; 
    ax = axes;
    ax.Parent = f2;
    surf(tSpec, f, 10*log10(Sacc), ...
        'Parent', ax, ...
        'EdgeColor', 'none');
    hold(ax, 'on');
    % xlabel('Time (min)');
    grid on
    axis(ax, 'tight')
    view(0,90)
    colorbar
    % ax.CLim = [-9, 9];
    % ax.YLim = [0, 20];
    % title([titStr, ', Washin, dBgain (Washin/Naive)'])

end



%% Identify movement artifact windows in spectrogram

[~, isMovArt] = util.remoutliers(sum(Sacc, 1), ...
    'bound', 'upper', ...
    'MADthresh', cfg.MADthresh);
temp = Sacc;
temp(:,isMovArt) = [];
SaccMarkOutliers = Sacc;
SaccMarkOutliers(:,isMovArt) = 100;


% Show Spectrogram with detected movement artifacts marked as 100's values
if cfg.displayWorkflowFigs
    f4 = figure;
    ax4 = axes;
    ax4.Parent = f4;
    surf(tSpec, f, 10*log10(SaccMarkOutliers), ...
        'Parent', ax4, ...
        'EdgeColor', 'none');
    hold(ax4, 'on');
    xlabel('Time (min)');
    grid on
    axis(ax4, 'tight')
    view(0,90)
    colorbar
    % ax4.YLim = [0, 300];
    % ax4.CLim = [-80, -30];
    title('Mov Artifacts marked');
    ylabel('Frequency (Hz)');
    f4.Position = [2555 57 560 421];

end

% Show Spectrogram with movement artifacts removed totally
if cfg.displayWorkflowFigs
    f4 = figure;
    ax4 = axes;
    ax4.Parent = f4;
%     tset = t;
%     tset(isMovArt) = [];
    surf(1:size(temp, 2), f, 10*log10(temp), ...
        'Parent', ax4, ...
        'EdgeColor', 'none');
    hold(ax4, 'on');
    xlabel('samples');
    grid on
    axis(ax4, 'tight')
    view(0,90)
    colorbar
    ax4.YLim = [0, 150];
    % ax4.CLim = [-80, -30];
    title('Mov Artifacts removed')
    ylabel('Frequency (Hz)');
    f4.Position = [2554 566 560 420];

end


% Get average PSD free of movement artifact windows
Sclean = temp; % movement artifact windows removed
PSD = mean(Sclean, 2);
if cfg.displayWorkflowFigs
    f1 = figure; ax = axes;
    plot(f, (PSD));
    grid on; 
    ax.XLim = [0, 35];
    %     ax.YLim = [0, popMaxPSD];
    xlabel('Frequency (Hz)');
%     title(['Minutes since harmaline inject: ' num2str(minutes(sessTabRow.harRefTime(1)))], 'Interpreter', 'none')

end
    
end

function [R,Pc] = corrPermute(x, y)

% Cross-correlation for 
% x = accLoMagSum;
% y = accHiMagSum;

[r, ~] = corrcoef(x, y);
R = r(2);

% x_boot = x;


% get p-test based on this empirical bootstrapp'd distribution
nBoots = 1000;
nSamps = length(x);
r_boot = zeros(nBoots, 1);
for iBoot = 1:nBoots
    x_boot = circshift(x, randi(nSamps));
    rtemp = corrcoef(x_boot, y);
    r_boot(iBoot) = rtemp(2);

end
Pc = sum(r_boot > R) / numel(r_boot);

end