% script for following IMU PSD over course of recording session part of the
% harmaline dose study in Uva

clear; close all

% expos 1, 2 mg/kg: TremoLfpDBS-190927-100155
% expos 1, 4 mg/kg: TremoLfpDBS-191004-100637
% expos 1, 6 mg/kg: TremoLfpDBS-191011-104322
% expos 1, 8 mg/kg: TremoLfpDBS-191018-100615
% expos 2, 2 mg/kg: TremoLfpDBS-191025-104651
% expos 2, 4 mg/kg: TremoLfpDBS-191101-101430
% expos 2, 6 mg/kg: TremoLfpDBS-191108-101829
% expos 2, 8 mg/kg: TremoLfpDBS-191115-100127



%% Choose harmaline session
clear nwb
nwbDataPath = 'D:\PROJECTS\Thalamic DBS for Harmaline Tremors\Data Acquisition\NWBdata\';
projRootPath = 'L:\My Drive\PROJECTS\Thalamic DBS for Harmaline Tremors\';


% SESSION_ID = 'TremoLfpDBS-190927-100155'; % expos 1, 2 mg/kg
% SESSION_ID = 'TremoLfpDBS-191004-100637'; % expos 1, 4 mg/kg
% SESSION_ID = 'TremoLfpDBS-191011-104322'; % expos 1, 6 mg/kg 
% SESSION_ID = 'TremoLfpDBS-191018-100615'; % expos 1, 8 mg/kg
% SESSION_ID = 'TremoLfpDBS-191025-104651'; % expos 2, 2 mg/kg
% SESSION_ID = 'TremoLfpDBS-191101-101430'; % expos 2, 4 mg/kg
% SESSION_ID = 'TremoLfpDBS-191108-101829'; % expos 2, 6 mg/kg
SESSION_ID = 'TremoLfpDBS-191115-100127'; % expos 2, 8 mg/kg

% dose = 2;
% expos = 1;
% titStr = [num2str(dose) ' mg/kg, expos ' num2str(expos)];

% Load nwb master file for this session, get imu TimeSeries object
disp('Reading NWB file...')
nwb = nwbRead([nwbDataPath SESSION_ID '_MASTER.nwb']);
disp('DONE!')
imu = nwb.acquisition.get('IMU').deref();

% load just the accelerometry data
dims = imu.data.dims;
acc = imu.data.load([1, 1], [dims(1), 3]);
tst = imu.timestamps.load;



%% CONFIG & CONSTANTS

% decide whether to show all figures generated by workflow
cfg.displayWorkflowFigs = false;


cfg.fcDetrend = 1; % Hz


% Resampling parameters
% desired resampling frequency is a factor of the LFP sampling frequency:
% 2,034.5 Hz, divide by 20
cfg.resample.fsDesired = 101.7250; % Hz;
cfg.resample.gapThresh = 0.5; % seconds, if timestamps have bigger gap mark interp values as NaN
cfg.upSampFactor = 10;


% Movement artifact removal
cfg.art.MADthresh = 4; % median limit for outliers
cfg.art.artHighPass = 5; % Hz, highpass threshold for potential artifactual power


% Spectrogram parameters:
cfg.TWIN = 1; % seconds, sliding time-window of spectrogram
cfg.NOVERLAP = 0; % samples, no overlaps for these spectrogam windows


% Display of PSD 
% Note: if looking at PSD power, good range is: [0, 0.09] to emphasize 5-20 Hz
% Note: if looking at logPSD, good range is: [-35, -5] to emphasize 5-20 Hz
cfg.PSDdisp.timeWin = 2*60; % seconds
cfg.PSDdisp.YLim = [0 0.01]; % [] default, just auto scales; specify if all PSDs should display with the same Ylims
cfg.PSDdisp.timeSeriesYLim = [-0.06 0.06]; 


% Saving options for figure
cfg.savefig.saveTF = false; % TF, whether or not to save figure 
cfg.savefig.fullpath = [projRootPath, ...
    'Reports\Report-201028_harmalineDoseIMU\PSDflipbooks\expos2dose8\']; % filename and fullpath to save directory
cfg.savefig.formattype = 'tiff'; % input identical to formattype in saveas.m 
        

% Tremor frequency band
trPeak = 10; % Hz, major tremor component
trRange = 3; % limits of tremor band around major component
cfg.tremorBand = [4 15]; % Hz


% % Tremor frequency band
% % trPeak = 15; % Hz, major tremor component
% % trRange = 3; % limits of tremor band around major component
% cfg.lowBand = [7 13]; % Hz
% cfg.highBand = [18 22];



% General movement frequency band
cfg.generalBand = [1, 35];



%% Resample IMU accelerometry

% Define threshold for timestamp spacing inside which we would have to
% replace interpolated values with NaNs (note, necessary for really big
% gaps)
intervThresh = cfg.resample.gapThresh; % seconds
dt_tst = diff(tst);
isGap = dt_tst > intervThresh;

% desired resampling frequency is a factor of the LFP sampling frequency:
% 2,034.5 Hz, divide by 20
fsDesired = cfg.resample.fsDesired; 
fsUpsamp = fsDesired * cfg.upSampFactor;

disp('Resampling non-uniform IMU data...')
[sigUniform, tUniform] = util.upsampUniform(acc, tst, fsUpsamp);
        
for i = 1:3
    dataDec(:,i) = decimate(sigUniform(:,i), 10, 'fir');
    
end
timeDec = downsample(tUniform, cfg.upSampFactor);
disp('DONE!')

% detrend the data of steady state and super slow movement
fc = 0.1; % Hz highpass
[b,a] = butter(2, fc / (fsDesired/2), 'high');
dataFilt = filtfilt(b, a, dataDec);

accData = dataFilt;


% Assign NaN value to any data taking place within a long gap of time
% according to original timestamps. Current data may be a simple linear
% interpolation between a large time gap, so make it a NaN to keep analysis
% good...
nGaps = sum(isGap);
idxGaps = find(isGap);
isNanTime = false(length(accData), 1);
for iGap = 1:nGaps
    timeBand = [tst(idxGaps(iGap)), tst(idxGaps(iGap)+1)];
    
    % Discover which indices in newly-upsampled time and data pertain to gap times
    temp = (timeDec >= timeBand(1)) & (timeDec < timeBand(2));
    isNanTime = isNanTime | temp;
    
end
% Set NaN values for accelerometry data interpolated between large gaps
accData(isNanTime,1:3) = NaN;  

time = timeDec;
fs = fsDesired;



%% Loop thru time windows and observe Tremor PSDs
clear figLims

% define time (in mins) of harmaline injection for today
expEpochs = nwb.intervals_epochs.deref();
T = nwbnrtl.util.readEpochsTable(expEpochs);
harTime = T{strcmp('harWashinExp', T.tag), 'start_time'};



% Approach: get spectrogram of all data, then segment out PSDs
window = floor(cfg.TWIN * fs);

% Sum PSDs from all 3 accel channels
clear Z S
for ch = 1:3
    [Z(:,:,ch), f, tSpec] = spectrogram(accData(:,ch), window, cfg.NOVERLAP, [], fs, 'yaxis');
    % tRef = linspace(tSpec(1), tSpec(end), numel(tSpec));
    S(:,:,ch) = abs(Z(:,:,ch));
    S(:,:,ch) = S(:,:,ch).^2;

end
tSpec = tSpec + time(1); % make sure tSpec reflects NWB-referenced time

% Combine spectral power from all three axes (summate)
Ssum = sum(S, 3);

axSess = displaySessionAcc(Ssum, tSpec, f, accData, time, harTime);
% axSess(1).CLim = [-35 -5];




% Identify sharp transient artifacts, tons of spectral leakage. Note, we
% ignore the very low frequencies because they indicate slow movement;
% broad spectral leakage in the tremor frequencies indicate transient sharp
% artifact...
Stest = Ssum((f > cfg.art.artHighPass),:);
[~, isMovArt] = util.remoutliers(sum(Stest, 1), ...
    'bound', 'upper', ...
    'MADthresh', cfg.art.MADthresh);

% Set spectrogram windows with artifact to all NaNs
SsumClean = Ssum;
SsumClean(:,isMovArt) = NaN;



    
% Gather average PSDs from sections of the spectrogram, track over time
twin = cfg.PSDdisp.timeWin; 
twinEdges = tSpec(1):twin:tSpec(end);
nWins = length(twinEdges)-1;
PSD = zeros(length(f), nWins);
for iWin = 1:nWins
    
    isSeg = (tSpec >= twinEdges(iWin)) & (tSpec < twinEdges(iWin+1)); 
    specSeg = Ssum(:,isSeg);
    specSegClean = SsumClean(:,isSeg);
    
    PSD(:,iWin) = mean(specSegClean, 2, 'omitnan');

    
    if cfg.displayWorkflowFigs
        close all

        figure; 
        set(gcf, 'Position', [1954 106 1828 867]);

        
        % display spectrogram before removing any artifact
        ax = subplot(2,3,1); 
        surf(1:size(specSeg, 2), f, 10*log10(specSeg), ...
            'Parent', ax, ...
            'EdgeColor', 'none');
        hold(ax, 'on');
        grid on
        axis(ax, 'tight')
        view(0,90)
        colorbar
        title('Original data'); xlabel('samples'); ylabel('Frequency (Hz)');
        if ~isempty(cfg.PSDdisp.YLim)
            set(gca, 'CLim', cfg.PSDdisp.YLim);

        end
  
        
        % display spectrogram after removeing artifact
        ax4 = subplot(2,3,2); 
        surf(1:size(specSegClean, 2), f, 10*log10(specSegClean), ...
            'Parent', ax4, ...
            'EdgeColor', 'none');
        hold(ax4, 'on');
        xlabel('Time (min)');
        grid on
        axis(ax4, 'tight')
        view(0,90)
        colorbar
        title('Mov Artifacts marked'); xlabel('samples'); ylabel('Frequency (Hz)');
        if ~isempty(cfg.PSDdisp.YLim)
            set(gca, 'CLim', cfg.PSDdisp.YLim);

        end
        
        
        % Get clean PSD and display
        ax = subplot(2,3,3); 
        plot(f, 10*log10(PSD(:,iWin)));
        grid on; 
        ax.XLim = [0, 35];
        xlabel('Frequency (Hz)'); ylabel('10*log10 Power')
        title('Clean PSD')
        if ~isempty(cfg.PSDdisp.YLim)
            set(gca, 'YLim', cfg.PSDdisp.YLim);

        end
        

        % specify time since harmaline inject at start time of segment
        sinceHarTime = twinEdges(iWin) - harTime;
        title(['Minutes since har inject: ' num2str(sinceHarTime/60)])
        
        
        % Also show the corresponding window of timeseries acc data
        isInWin = (time >= twinEdges(iWin)) & (time < twinEdges(iWin+1)); 
        subplot(2,3,4:6); 
        plot(time(isInWin), accData(isInWin,1:3));
        title([num2str(twin) '-second segment']); xlabel('Time (seconds)'); 
        set(gca, 'YLim', cfg.PSDdisp.timeSeriesYLim);
        
        
        % Save figure if option is on
        if cfg.savefig.saveTF
            saveas(gcf, [cfg.savefig.fullpath '_win' num2str(iWin)], cfg.savefig.formattype);

        end
        
    end

    
end



%% View "cleaned" and "downsampled" spectrogram

% display spectrogram before removing any artifact
figure; set(gcf, 'Position', [1954 425 1828 548]);
ax = axes; 
% surf((twinEdges(1:(end-1)) - harTime)/60, f, 10*log10(PSD), ...
%     'Parent', ax, ...
%     'EdgeColor', 'none');
surf((twinEdges(1:(end-1)) - harTime)/60, f, PSD, ...
    'Parent', ax, ...
    'EdgeColor', 'none');
hold(ax, 'on');
grid on
axis(ax, 'tight')
view(0,90)
colorbar
title('Mov Arts removed'); xlabel('time (mins)'); ylabel('Frequency (Hz)');
if ~isempty(cfg.PSDdisp.YLim)
    set(gca, 'CLim', cfg.PSDdisp.YLim);

end



%% Follow power of particular band over time

% Sum the PSD over the chosen frequency band, over time
figure; set(gcf, 'Position', [1996 129 1413 848]);

cfg.tremorBand = [8 12];
isBand = (f >= cfg.tremorBand(1)) & (f < cfg.tremorBand(2));
trPow = sum(PSD(isBand,:), 1);
subplot(3,1,1); 
plot((twinEdges(1:(end-1)) - harTime)/60, (trPow));
set(gca, 'YLim', [0 1.5]);
title(['Tremor [' num2str(cfg.tremorBand(1)) ', ' num2str(cfg.tremorBand(2)) '] Hz Power'])

cfg.movBand = [0.3 3];
isBand = (f >= cfg.movBand(1)) & (f < cfg.movBand(2));
movPow = sum(PSD(isBand,:), 1);
subplot(3,1,2);
plot((twinEdges(1:(end-1)) - harTime)/60, (movPow));
title(['Movement [' num2str(cfg.movBand(1)) ', ' num2str(cfg.movBand(2)) '] Hz Power'])


MPR = trPow ./ movPow;
subplot(3,1,3);
plot((twinEdges(1:(end-1)) - harTime)/60, (MPR));
title('Tremor/Movement Power Ratio')


%% SUB-FUNCTIONS

function [ax] = displaySessionAcc(Ssum, tSpec, f, accData, time, harTime)
f2 = figure; 
ax(1) = subplot(2,1,1);
tSpec = tSpec + time(1); % have spectrogram time reflect NWB-time
surf((tSpec-harTime)/60, f, 10*log10(Ssum), ...
    'Parent', ax(1), ...
    'EdgeColor', 'none');
% surf((tSpec-harTime)/60, f, 10*log10(Ssum), ...
%     'Parent', ax, ...
%     'EdgeColor', 'none');
hold(ax(1), 'on');
% xlabel('Time (min)');
grid on
axis(ax(1), 'tight')
view(0,90)
colorbar
title('Original data spectrogram'); xlabel('Time since harmaline Inject (mins)');

% display timeseries as well
% t = (1/fs) * (0:(length(accData)-1))'; % time in seconds
ax(2) = subplot(2,1,2);
plot((time-harTime)/60, accData);
% plot((time-harTime)/60, accData);
title('Original data timeseries'); xlabel('Time since harmaline Inject (mins)');
set(gcf, 'Position', [1932 184 1833 796]);

end

function [fPeakTr,aTremorPow,aPowRatio] = tremorWorkflow(sessTabRow, dataAcqPn, cfg)
% Based on approach used in "script_displayMelaTremorInTime.m", but adapted
% for Uva's stuff

% Load in data and get into format of "acc" and "fs"
% fn = sessTabRow.filename{1};
% dataTab = readtable([dataAcqPn directoryPn fn]);

tdt = TDTbin2mat([ dataAcqPn sessTabRow.TDTtank{1} '\' sessTabRow.TDTblock{1}], ...
    'STORE', 'Acc3');

fs = tdt.streams.Acc3.fs; % hz
acc = double(tdt.streams.Acc3.data');
% t = 1/fs * (0:(height(dataTab) - 1))';
disp(sessTabRow.TDTblock{1})




% Custom Sub-function:
[f,PSD] = getCleanPSD(acc, fs, cfg);


% TRACK peak frequency results for table
fPeakTr = f(PSD == max(PSD));

% TRACK sum of tremor power
isLoBand = (f >= cfg.lowBand(1)) & (f < cfg.lowBand(2));
isHiBand = (f >= cfg.highBand(1)) & (f < cfg.highBand(2));
isTremor = isLoBand | isHiBand;
aTremorPow = sum(PSD(isTremor));

% isTremor = (f >= cfg.tremorBand(1)) & (f < cfg.tremorBand(2));
aTremorPow = sum(PSD(isTremor));



% Get Ratio of tremor power vs general movmement power
% Use a log-tranformed PSD power

% TRACK sum of tremor power
isGenMov = (f >= cfg.generalBand(1)) & (f < cfg.generalBand(2));
aGenPow = sum(PSD(isGenMov));

% Mean Power for total time
aPowRatio = aTremorPow / aGenPow;


end

function [f,PSD] = getCleanPSD(acc, fs, cfg)
% 
% INPUTS
% acc - triaxial accelerometer data, column oriented
%  fs - sampling freq of said accelerometer data
% cfg.
%     fcDetrend - highpass filter cutoff for detrending acc data (Hz)
%     TWIN - window to be used for spectrogram
%     NOVERLAP - samples of overlap for spectrogram windows
%     displayWorkflowFigs - TF value for whether or not to show figures of
%                           intermediate steps

   

%


% % Load in data and get into format of "acc" and "fs"
% fn = sessTabRow.filename{1};
% dataTab = readtable([dataAcqPn directoryPn fn]);
% t = 1/fs * (0:(height(dataTab) - 1))';
% acc = [dataTab.Channel1, dataTab.Channel2, dataTab.Channel3];

% Detrend data, linear best fit is subtracted from each channel
acc = detrend(acc);


% Highpass filter out slow components

[b,a] = butter(3, cfg.fcDetrend/(fs/2), 'high');
accFilt = filtfilt(b, a, acc);



% Get combined triaxial spectrogram

window = floor(cfg.TWIN * fs);

% Sum PSDs from all 3 accel channels
clear Z S
for ch = 1:3
    [Z(:,:,ch), f, tSpec] = spectrogram(accFilt(:,ch), window, cfg.NOVERLAP, [], fs, 'yaxis');
    % tRef = linspace(tSpec(1), tSpec(end), numel(tSpec));
    S(:,:,ch) = abs(Z(:,:,ch));
    S(:,:,ch) = S(:,:,ch).^2;

end
% Combine spectral power from all three axes (summate)
Sacc = sum(S, 3);

% Get average power (S) PSD over time
% PSDWashNorm = Swash ./ (repmat(PSDbaseAv, 1, size(Swash, 2)));
if cfg.displayWorkflowFigs
    f2 = figure; 
    ax = axes;
    ax.Parent = f2;
    surf(tSpec, f, 10*log10(Sacc), ...
        'Parent', ax, ...
        'EdgeColor', 'none');
    hold(ax, 'on');
    % xlabel('Time (min)');
    grid on
    axis(ax, 'tight')
    view(0,90)
    colorbar
    % ax.CLim = [-9, 9];
    % ax.YLim = [0, 20];
    % title([titStr, ', Washin, dBgain (Washin/Naive)'])
    set(f2, 'Position', [1977 561 560 420])
    title('Original data');
    
    % display timeseries as well
    t = (1/fs) * (0:(length(acc)-1)); % time in seconds
    figure; 
    plot(t', acc);
    title('Original data timeseries');
    set(gcf, 'Position', [1976 52 560 420]);

end



% Identify movement artifact windows in spectrogram

[~, isMovArt] = util.remoutliers(sum(Sacc, 1), ...
    'bound', 'upper', ...
    'MADthresh', cfg.art.MADthresh);

% % temporarily negate this step:
% isMovArt(:) = 0;

temp = Sacc;
temp(:,isMovArt) = [];
SaccMarkOutliers = Sacc;
SaccMarkOutliers(:,isMovArt) = 100;


% Show Spectrogram with detected movement artifacts marked as 100's values
if cfg.displayWorkflowFigs
    f4 = figure;
    ax4 = axes;
    ax4.Parent = f4;
    surf(tSpec, f, 10*log10(SaccMarkOutliers), ...
        'Parent', ax4, ...
        'EdgeColor', 'none');
    hold(ax4, 'on');
    xlabel('Time (min)');
    grid on
    axis(ax4, 'tight')
    view(0,90)
    colorbar
    % ax4.YLim = [0, 300];
    % ax4.CLim = [-80, -30];
    title('Mov Artifacts marked');
    ylabel('Frequency (Hz)');
%     f4.Position = [2555 57 560 421];
    set(gcf, 'Position', [2545 562 560 421]);

end

% Show Spectrogram with movement artifacts removed totally
if cfg.displayWorkflowFigs
    f4 = figure;
    ax4 = axes;
    ax4.Parent = f4;
%     tset = t;
%     tset(isMovArt) = [];
    surf(1:size(temp, 2), f, 10*log10(temp), ...
        'Parent', ax4, ...
        'EdgeColor', 'none');
    hold(ax4, 'on');
    xlabel('samples');
    grid on
    axis(ax4, 'tight')
    view(0,90)
    colorbar
    ax4.YLim = [0, 50];
    % ax4.CLim = [-80, -30];
    title('Mov Artifacts removed')
    ylabel('Frequency (Hz)');
%     f4.Position = [2554 566 560 420];
    set(gcf, 'Position', [3122 565 560 420]);

end


% Get average PSD free of movement artifact windows
Sclean = temp; % movement artifact windows removed
PSD = mean(Sclean, 2);
if cfg.displayWorkflowFigs
    f1 = figure; ax = axes;
    plot(f, (PSD));
    grid on; 
    ax.XLim = [0, 35];
    %     ax.YLim = [0, popMaxPSD];
    xlabel('Frequency (Hz)');
    set(gcf, 'Position', [3123 57 560 420]);
    title('Clean PSD')
    if ~isempty(cfg.PSDdisp.YLim)
        set(gca, 'YLim', cfg.PSDdisp.YLim);
        
    end
%     title(['Minutes since harmaline inject: ' num2str(minutes(sessTabRow.harRefTime(1)))], 'Interpreter', 'none')

end
    
end

function [PSD,f] = specgram2PSD(Sacc, f, cfg)
% 
% INPUTS
% acc - triaxial accelerometer data, column oriented
%  fs - sampling freq of said accelerometer data
% cfg.
%     fcDetrend - highpass filter cutoff for detrending acc data (Hz)
%     TWIN - window to be used for spectrogram
%     NOVERLAP - samples of overlap for spectrogram windows
%     displayWorkflowFigs - TF value for whether or not to show figures of
%                           intermediate steps

   

%


% % Load in data and get into format of "acc" and "fs"
% fn = sessTabRow.filename{1};
% dataTab = readtable([dataAcqPn directoryPn fn]);
% t = 1/fs * (0:(height(dataTab) - 1))';
% acc = [dataTab.Channel1, dataTab.Channel2, dataTab.Channel3];

% % Detrend data, linear best fit is subtracted from each channel
% acc = detrend(acc);
% 
% 
% % Highpass filter out slow components
% 
% [b,a] = butter(3, cfg.fcDetrend/(fs/2), 'high');
% accFilt = filtfilt(b, a, acc);
% 
% 
% 
% %% Get combined triaxial spectrogram
% 
% window = floor(cfg.TWIN * fs);
% 
% % Sum PSDs from all 3 accel channels
% clear Z S
% for ch = 1:3
%     [Z(:,:,ch), f, tSpec] = spectrogram(accFilt(:,ch), window, cfg.NOVERLAP, [], fs, 'yaxis');
%     % tRef = linspace(tSpec(1), tSpec(end), numel(tSpec));
%     S(:,:,ch) = abs(Z(:,:,ch));
%     S(:,:,ch) = S(:,:,ch).^2;
% 
% end
% % Combine spectral power from all three axes (summate)
% Sacc = sum(S, 3);

% Get average power (S) PSD over time
% PSDWashNorm = Swash ./ (repmat(PSDbaseAv, 1, size(Swash, 2)));
if cfg.displayWorkflowFigs
    f2 = figure; 
    ax = axes;
    ax.Parent = f2;
    surf(1:size(Sacc, 2), f, 10*log10(Sacc), ...
        'Parent', ax, ...
        'EdgeColor', 'none');
    hold(ax, 'on');
    % xlabel('Time (min)');
    grid on
    axis(ax, 'tight')
    view(0,90)
    colorbar
    % ax.CLim = [-9, 9];
    % ax.YLim = [0, 20];
    % title([titStr, ', Washin, dBgain (Washin/Naive)'])
    set(f2, 'Position', [1977 561 560 420])
    title('Original data');
    
%     % display timeseries as well
%     t = (1/fs) * (0:(length(acc)-1)); % time in seconds
%     figure; 
%     plot(t', acc);
%     title('Original data timeseries');
%     set(gcf, 'Position', [1976 52 560 420]);

end



% Identify movement artifact windows in spectrogram
% 
% [~, isMovArt] = util.remoutliers(sum(Sacc, 1), ...
%     'bound', 'upper', ...
%     'MADthresh', cfg.art.MADthresh);
% 
% % % temporarily negate this step:
% % isMovArt(:) = 0;
% 
% temp = Sacc;
% temp(:,isMovArt) = [];
% SaccMarkOutliers = Sacc;
% SaccMarkOutliers(:,isMovArt) = 100;
% 
% 
% % Show Spectrogram with detected movement artifacts marked as 100's values
% if cfg.displayWorkflowFigs
%     f4 = figure;
%     ax4 = axes;
%     ax4.Parent = f4;
%     surf(tSpec, f, 10*log10(SaccMarkOutliers), ...
%         'Parent', ax4, ...
%         'EdgeColor', 'none');
%     hold(ax4, 'on');
%     xlabel('Time (min)');
%     grid on
%     axis(ax4, 'tight')
%     view(0,90)
%     colorbar
%     % ax4.YLim = [0, 300];
%     % ax4.CLim = [-80, -30];
%     title('Mov Artifacts marked');
%     ylabel('Frequency (Hz)');
% %     f4.Position = [2555 57 560 421];
%     set(gcf, 'Position', [2545 562 560 421]);
% 
% end
% 
% % Show Spectrogram with movement artifacts removed totally
% if cfg.displayWorkflowFigs
%     f4 = figure;
%     ax4 = axes;
%     ax4.Parent = f4;
% %     tset = t;
% %     tset(isMovArt) = [];
%     surf(1:size(temp, 2), f, 10*log10(temp), ...
%         'Parent', ax4, ...
%         'EdgeColor', 'none');
%     hold(ax4, 'on');
%     xlabel('samples');
%     grid on
%     axis(ax4, 'tight')
%     view(0,90)
%     colorbar
%     ax4.YLim = [0, 50];
%     % ax4.CLim = [-80, -30];
%     title('Mov Artifacts removed')
%     ylabel('Frequency (Hz)');
% %     f4.Position = [2554 566 560 420];
%     set(gcf, 'Position', [3122 565 560 420]);
% 
% end


% Get average PSD free of movement artifact windows

% figure; plot(f, PSD);

Sclean = Sacc; % movement artifact windows removed
PSD = mean(Sclean, 2, 'omitnan');
if cfg.displayWorkflowFigs
    f1 = figure; ax = axes;
    plot(f, (PSD));
    grid on; 
    ax.XLim = [0, 35];
    %     ax.YLim = [0, popMaxPSD];
    xlabel('Frequency (Hz)');
    set(gcf, 'Position', [3123 57 560 420]);
    title('Clean PSD')
    if ~isempty(cfg.PSDdisp.YLim)
        set(gca, 'YLim', cfg.PSDdisp.YLim);
        
    end
%     title(['Minutes since harmaline inject: ' num2str(minutes(sessTabRow.harRefTime(1)))], 'Interpreter', 'none')

end
    
end



